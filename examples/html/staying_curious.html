<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Staying Curious: Your Lifelong Learning Journey - Data v1.0 - CISK Navigator v2.7.10</title>

<style>
  :root {
    --bg: #0b1220;
    --panel: #101a30;
    --panel2: #0f1730;
    --text: #e8eefc;
    --muted: #a9b5d6;
    --border: rgba(255,255,255,0.10);
    --shadow: 0 10px 30px rgba(0,0,0,0.35);
    --radius: 14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";

    /* CISK Colors - Configurable via YAML */
    --c-challenge: #ec4899;
    --c-challenge-bg: #ec489923;
    --c-challenge-border: #ec48998C;
    --c-challenge-light: #ec48991A;

    --c-initiative: #8b5cf6;
    --c-initiative-bg: #8b5cf623;
    --c-initiative-border: #8b5cf68C;
    --c-initiative-light: #8b5cf61A;

    --c-system: #14b8a6;
    --c-system-bg: #14b8a61F;
    --c-system-border: #14b8a68C;

    --c-kpi: #f59e0b;
    --c-kpi-bg: #f59e0b1F;
    --c-kpi-border: #f59e0b8C;

    /* Priority Colors */
    --priority-high: #f59e0b;
    --priority-medium: #eab308;
    --priority-low: #84cc16;

    /* Impact Colors */
    --impact-high: #ef4444;
    --impact-medium: #f59e0b;
    --impact-low: #10b981;

    /* Weight/Badge Colors */
    --weight-bg: #3b82f6;
    --weight-border: #1d4ed8;

    /* Graph Node Colors */
    --graph-group: #fbbf24;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: var(--sans);
    background:
      radial-gradient(1200px 800px at 20% 0%, rgba(106,166,255,.14), transparent 55%),
      radial-gradient(900px 700px at 90% 10%, rgba(34,197,94,.10), transparent 60%),
      var(--bg);
    color: var(--text);
  }
  .wrap { max-width: 1250px; margin: 0 auto; padding: 0 16px; }
  header {
    position: sticky; top: 0; z-index: 20;
    background: linear-gradient(to bottom, rgba(11,18,32,.95), rgba(11,18,32,.70));
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border);
  }
  .topbar { display:flex; align-items:center; justify-content: space-between; gap: 12px; padding: 14px 0; }
  .title {
    font-weight: 800;
    letter-spacing: .2px;
    font-size: 15px;
    line-height: 1.2;
  }
  .tabs { display:flex; gap: 8px; flex-wrap: wrap; }
  .seasonbar{display:flex;align-items:center;gap:8px;flex-wrap:wrap;padding:0 0 12px 0;}
  .seasonlabel{font-size:12px;color:var(--muted);margin-right:4px;}
  .tabbtn {
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.03);
    color: var(--muted);
    padding: 8px 10px;
    border-radius: 999px;
    font-size: 12px;
    cursor: pointer;
  }
  .tabbtn.active {
    color: var(--text);
    border-color: rgba(143,208,255,.45);
    background: rgba(143,208,255,.10);
  }
  main { padding: 16px 0 28px; }
  .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
  @media (max-width: 1100px) { .grid2 { grid-template-columns: 1fr; } }

  /* Enhanced: 4-column grid */
  .grid4 { display:grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
  @media (max-width: 1400px) { .grid4 { grid-template-columns: repeat(2, 1fr); } }
  @media (max-width: 900px) { .grid4 { grid-template-columns: 1fr; } }

  /* Enhanced: Priority stars */
  .priority {
    display: inline-flex;
    align-items: center;
    font-size: 14px;
    margin-left: 6px;
  }
  .priority-1 { color: #f59e0b; } /* ‚≠ê‚≠ê‚≠ê High */
  .priority-2 { color: #eab308; } /* ‚≠ê‚≠ê Medium */
  .priority-3 { color: #84cc16; } /* ‚≠ê Low */

  /* Enhanced: Impact badges */
  .impact {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    text-transform: uppercase;
    margin-left: 6px;
  }
  .impact-H { background: #ef4444; color: white; } /* High */
  .impact-M { background: #f59e0b; color: white; } /* Medium */
  .impact-L { background: #10b981; color: white; } /* Low */

  /* Enhanced: Weight indicators */
  .weight {
    display: inline-flex;
    align-items: center;
    padding: 2px 6px;
    background: linear-gradient(135deg, #3b82f6, #1d4ed8);
    border-radius: 4px;
    font-size: 10px;
    font-weight: 700;
    color: white;
    margin-left: 4px;
  }
  .weight-bar {
    display: inline-block;
    height: 4px;
    background: rgba(59, 130, 246, 0.3);
    border-radius: 2px;
    overflow: hidden;
    width: 50px;
    margin-left: 6px;
    vertical-align: middle;
  }
  .weight-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #3b82f6, #1d4ed8);
    transition: width 0.3s ease;
  }

  /* Enhanced: Link indicators */
  .link-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 6px 8px;
    margin: 4px 0;
    background: rgba(0,0,0,0.12);
    border-radius: 8px;
    border-left: 3px solid var(--c-initiative);
  }
  .link-item:hover {
    background: rgba(0,0,0,0.20);
  }
  .link-info {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .panel {
    background: rgba(16,26,48,.88);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow: hidden;
  }
  .panel .hd {
    padding: 12px 12px 10px;
    border-bottom: 1px solid var(--border);
    background: rgba(0,0,0,0.10);
  }
  .h1 { font-size: 13px; font-weight: 800; letter-spacing: .2px; }
  .h2 { margin-top: 4px; font-size: 12px; color: var(--muted); line-height: 1.25; }
  .panel .bd { padding: 12px; }

  .search {
    display:flex; gap: 10px; align-items:center;
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 8px 10px;
    background: rgba(0,0,0,0.10);
  }
  .search input {
    width: 100%;
    background: transparent;
    border: 0;
    color: var(--text);
    font-size: 13px;
    outline: none;
  }

  .mono { font-family: var(--mono); }
  .muted { color: var(--muted); }

  .chip {
    display:inline-flex; align-items:center;
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 2px 8px;
    font-size: 11px;
    color: var(--muted);
    background: rgba(255,255,255,0.03);
  }
  .chip.group {
    background: var(--c-challenge-bg);
    border-color: rgba(240,210,79,.55);
    color: rgba(255, 242, 190, 0.98);
    font-weight: 800;
  }
  .chip.season {
    background: rgba(143,208,255,.10);
    border-color: rgba(143,208,255,.45);
    color: #dbe9ff;
    font-weight: 800;
  }

  .tree details { border-left: 4px solid var(--c-challenge); padding-left: 10px; }
  .tree details + details { margin-top: 8px; }
  .tree summary {
    list-style: none;
    cursor: pointer;
    user-select: none;
    padding: 6px 6px;
    border-radius: 10px;
    display:flex; align-items:center; justify-content: space-between;
  }
  .tree summary:hover { background: rgba(255,255,255,0.03); }
  .tree summary.active { background: rgba(240,210,79,.10); border: 1px solid rgba(240,210,79,.25); }
  .tree summary::-webkit-details-marker { display:none; }
  .sub { margin: 8px 0 10px 0; display:flex; flex-direction: column; gap: 6px; }
  .subitem {
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 8px 10px;
    font-size: 12.5px;
    cursor: pointer;
    background: rgba(0,0,0,0.08);
  }
  .subitem:hover { border-color: rgba(240,210,79,.35); }
  .subitem.active { border-color: rgba(240,210,79,.65); background: rgba(240,210,79,.10); }

  .list { display:flex; flex-direction: column; gap: 8px; margin-top: 12px; }
  .item {
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px;
    cursor: pointer;
    background: rgba(0,0,0,0.08);
  }
  .item:hover { border-color: rgba(143,208,255,.35); }
  .item.active { border-color: rgba(143,208,255,.65); background: rgba(143,208,255,.08); }
  .item .t { font-weight: 750; font-size: 12.5px; }
  .item .m { margin-top: 4px; font-size: 11.5px; color: var(--muted); line-height: 1.35; }
  .row { display:flex; align-items:center; gap: 8px; }

  .btn {
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.03);
    color: var(--text);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 12px;
    cursor: pointer;
  }
  .btn.small { padding: 6px 8px; font-size: 11px; border-radius: 10px; }
  .btn.ghost { background: transparent; }
  .btn.primary {
    border-color: rgba(143,208,255,.45);
    background: rgba(143,208,255,.10);
  }

  .card {
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 12px;
    background: rgba(0,0,0,0.12);
  }
  .card h2 {
    margin: 0 0 6px 0;
    font-size: 15px;
    letter-spacing: .2px;
  }
  .card h3 {
    margin: 14px 0 8px 0;
    font-size: 12px;
    letter-spacing: .2px;
    color: rgba(255,255,255,0.92);
  }
  .hr { height: 1px; background: var(--border); margin: 12px 0; }

  .pillwrap { display:flex; flex-wrap: wrap; gap: 8px; }
  .pill {
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 11.5px;
    cursor: pointer;
    background: rgba(255,255,255,0.03);
  }
  .pill:hover { filter: brightness(1.05); }
  .pill.chall { border-color: rgba(240,210,79,.55); background: rgba(240,210,79,.10); }
  .pill.init { border-color: rgba(143,208,255,.55); background: rgba(143,208,255,.10); }
  .pill.sys { border-color: rgba(29,78,216,.55); background: rgba(29,78,216,.12); }
  .pill.kpi { border-color: rgba(34,197,94,.55); background: rgba(34,197,94,.12); }

  .badge {
    display:inline-flex; align-items:center; justify-content:center;
    min-width: 34px;
    padding: 2px 8px;
    border-radius: 999px;
    font-size: 11px;
    font-weight: 900;
    border: 1px solid var(--border);
  }
  .badge.ch { background: rgba(240,210,79,.16); border-color: rgba(240,210,79,.55); color: rgba(255,242,190,.98); }
  .badge.in { background: rgba(143,208,255,.14); border-color: rgba(143,208,255,.55); color: #dbe9ff; }
  .badge.sy { background: rgba(29,78,216,.14); border-color: rgba(29,78,216,.55); color: rgba(210,225,255,.98); }
  .badge.kp { background: rgba(34,197,94,.14); border-color: rgba(34,197,94,.55); color: rgba(200,255,220,.98); }

  .footer { margin-top: 10px; font-size: 11.5px; color: var(--muted); }

  /* Workbench */
  .kanban { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; }
  @media (max-width: 1100px) { .kanban { grid-template-columns: 1fr; } }
  .col {
    border: 1px dashed rgba(255,255,255,0.18);
    border-radius: 14px;
    padding: 10px;
    background: rgba(0,0,0,0.10);
    min-height: 220px;
  }
  .col h3 { margin: 0 0 8px 0; font-size: 12px; letter-spacing: .4px; color: var(--muted); text-transform: uppercase; }
  .wcard { border: 1px solid var(--border); border-radius: 12px; padding: 10px; background: rgba(0,0,0,0.14); margin-bottom: 8px; }
  .wcard .t { font-size: 12.5px; font-weight: 750; }
  .wcard .m { font-size: 11.5px; color: var(--muted); margin-top: 4px; line-height: 1.35; }
  .wcard .actions { margin-top: 8px; display:flex; gap: 6px; flex-wrap: wrap; }

  /* Graph View - Mobile responsive */
  @media (max-width: 768px) {
    .graph-header {
      flex-direction: column !important;
      align-items: flex-start !important;
      gap: 12px;
    }
    .graph-title {
      width: 100%;
    }
    .graph-controls {
      width: 100%;
      flex-wrap: wrap;
      justify-content: flex-start;
    }
    .graph-controls .btn {
      flex: 0 0 auto;
    }
  }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="topbar">
      <div class="title">Staying Curious: Your Lifelong Learning Journey <span style="opacity: 0.6; font-size: 0.9em;">(Data v1.0 ‚Ä¢ App v2.7.10)</span></div>
      <div class="tabs" id="tabs"></div>
    </div>
    <div class="seasonbar">
      <span class="seasonlabel">Season:</span>
      <button class="btn small ghost" data-season="ALL" onclick="setInitSeason('ALL')">All</button>
      <button class="btn small" data-season="S1" onclick="setInitSeason('S1')">S1</button>
      <button class="btn small" data-season="S2" onclick="setInitSeason('S2')">S2</button>
      <button class="btn small" data-season="S3" onclick="setInitSeason('S3')">S3</button>
      <span class="muted" style="margin:0 6px">|</span>
      <button class="btn small ghost" onclick="clearSelection()">Show all</button>
      <span class="muted" style="margin:0 6px">|</span>
      <span class="seasonlabel">View:</span>
      <button class="btn small primary" id="btnColumnView" onclick="setViewMode('column')">üìã Column</button>
      <button class="btn small" id="btnGraphView" onclick="setViewMode('graph')">üï∏Ô∏è Graph</button>
      <button class="btn small" id="btnFlowView" onclick="setViewMode('flow')">üåä Flow</button>
    </div>
  </div>
</header>



<main>
  <div class="wrap" id="columnView">
    <div id="tab-challenges" class="tab">
      <div class="grid2">
        <div class="panel">
          <div class="hd">
            <div class="h1">Challenges tree</div>
            <div class="h2">Click a challenge group (summary) or a sub‚Äëchallenge.</div>
          </div>
          <div class="bd">
            <div class="search"><span class="chip mono">/</span><input id="searchChallenges" placeholder="Search challenges‚Ä¶" /></div>
            <div class="tree" id="challengeTree" style="margin-top:12px"></div>
            <div class="footer">Tip: sub‚Äëchallenge view uses a best‚Äëmatch mapping; parent challenge shows ALL items.</div>
          </div>
        </div>
        <div class="panel" id="challengeDetail">
          <div class="hd"><div class="h1">Details</div><div class="h2">Select something on the left.</div></div>
          <div class="bd" id="challengeDetailBody"></div>
        </div>
      </div>
    </div>

    <div id="tab-initiatives" class="tab" style="display:none">
      <div class="grid2">
        <div class="panel">
          <div class="hd"><div class="h1">Initiatives</div><div class="h2">Search.</div></div>
          <div class="bd">
            <div class="search"><span class="chip mono">/</span><input id="searchInitiatives" placeholder="Search initiatives‚Ä¶" /></div>
            <div class="list" id="initiativeList"></div>
          </div>
        </div>
        <div class="panel" id="initiativeDetail">
          <div class="hd"><div class="h1">Details</div><div class="h2">Select an initiative.</div></div>
          <div class="bd" id="initiativeDetailBody"></div>
        </div>
      </div>
    </div>

    <div id="tab-systems" class="tab" style="display:none">
      <div class="grid2">
        <div class="panel">
          <div class="hd"><div class="h1">Systems / enablers</div><div class="h2">Search, then click for linked initiatives + KPIs.</div></div>
          <div class="bd">
            <div class="search"><span class="chip mono">/</span><input id="searchSystems" placeholder="Search systems‚Ä¶" /></div>
            <div class="list" id="systemList"></div>
          </div>
        </div>
        <div class="panel" id="systemDetail">
          <div class="hd"><div class="h1">Details</div><div class="h2">Select a system.</div></div>
          <div class="bd" id="systemDetailBody"></div>
        </div>
      </div>
    </div>

    <div id="tab-kpis" class="tab" style="display:none">
      <div class="grid2">
        <div class="panel">
          <div class="hd"><div class="h1">KPIs</div><div class="h2">Search, then click for linked systems + initiatives.</div></div>
          <div class="bd">
            <div class="search"><span class="chip mono">/</span><input id="searchKpis" placeholder="Search KPIs‚Ä¶" /></div>
            <div class="list" id="kpiList"></div>
          </div>
        </div>
        <div class="panel" id="kpiDetail">
          <div class="hd"><div class="h1">Details</div><div class="h2">Select a KPI.</div></div>
          <div class="bd" id="kpiDetailBody"></div>
        </div>
      </div>
    </div>

    <div id="tab-workbench" class="tab" style="display:none">
      <div class="panel">
        <div class="hd"><div class="h1">Workbench (pin / re‚Äëorder)</div><div class="h2">Pin items to build your own live Q&A navigation.</div></div>
        <div class="bd">
          <div class="row">
            <button class="btn" onclick="clearWorkbench()">Clear</button>
            <button class="btn" onclick="saveWorkbench()">Save</button>
            <button class="btn" onclick="loadWorkbench()">Load</button>
            <span class="chip">Tip: on iPad, use ‚Üë‚Üì if drag is awkward</span>
          </div>
          <div class="kanban" style="margin-top:12px" id="kanban"></div>
          <div class="footer">Pinned state is stored locally in your browser (safe to refresh).</div>
        </div>
      </div>
    </div>

  </div>

  <!-- Graph View -->
  <div class="wrap" id="graphView" style="display:none;">
    <div class="panel" style="min-height:900px;">
      <div class="hd">
        <div class="row graph-header" style="justify-content:space-between;">
          <div class="graph-title">
            <div class="h1">üï∏Ô∏è Graph View - CISK Flow Visualization</div>
            <div class="h2" id="graphSubtitle">Vertical flow: Groups ‚Üí Challenges ‚Üí Initiatives ‚Üí Systems ‚Üí KPIs</div>
          </div>
          <div class="row graph-controls" style="gap:8px;">
            <button class="btn small" id="graphBackBtn" onclick="graphGoBack()" style="display:none;">‚Üê Back</button>
            <button class="btn small" onclick="graphZoomIn()">üîç+ Zoom In</button>
            <button class="btn small" onclick="graphZoomOut()">üîç‚àí Zoom Out</button>
            <button class="btn small" onclick="graphFitToView()">‚ä° Fit to View</button>
            <button class="btn small" onclick="graphFontSizeIncrease()">A+ Text Larger</button>
            <button class="btn small" onclick="graphFontSizeDecrease()">A‚àí Text Smaller</button>
            <button class="btn small" onclick="graphReset()">‚Üª Reset</button>
          </div>
        </div>
        <div id="graphSelectionInfo" style="display:none;margin-top:8px;padding:8px;background:rgba(255,255,255,0.05);border-radius:8px;border:1px solid var(--border);">
          <div style="font-size:11px;color:var(--muted);margin-bottom:4px;">Selected:</div>
          <div style="font-size:12px;"></div>
        </div>
      </div>
      <div class="bd" style="padding:0;position:relative;">
        <canvas id="graphCanvas" style="width:100%;height:900px;cursor:grab;touch-action:none;"></canvas>
        <div id="graphTooltip" style="
          position:absolute;
          display:none;
          background:rgba(16,26,48,0.95);
          border:1px solid rgba(255,255,255,0.2);
          border-radius:8px;
          padding:8px 12px;
          color:var(--text);
          font-size:12px;
          line-height:1.4;
          pointer-events:none;
          z-index:100;
          max-width:300px;
          box-shadow:0 4px 12px rgba(0,0,0,0.4);
          backdrop-filter:blur(8px);
        "></div>
      </div>
      <div class="hd" style="border-top:1px solid var(--border);border-bottom:none;">
        <div class="row" style="gap:16px;font-size:11px;flex-wrap:wrap;">
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--graph-group);border-radius:4px;"></span> Groups</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-challenge);border-radius:4px;"></span> Sub-Challenges</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-initiative);border-radius:4px;"></span> Initiatives</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-system);border-radius:4px;"></span> Systems</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-kpi);border-radius:4px;"></span> KPIs</div>
          <span class="muted">|</span>
          <div class="muted">Click any node to filter ‚Ä¢ Use ‚Üê Back to restore</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Flow View (Sankey Diagram) -->
  <div class="wrap" id="flowView" style="display:none;">
    <div class="panel" style="min-height:900px;">
      <div class="hd">
        <div class="row" style="justify-content:space-between;">
          <div>
            <div class="h1">üåä Flow View - Sankey Diagram</div>
            <div class="h2" id="flowSubtitle">Visualize relationship strength through flow thickness</div>
            <div id="flowSelectionInfo" style="display:none;margin-top:8px;padding:6px 12px;background:rgba(255,255,255,0.1);border-radius:6px;font-size:12px;"></div>
          </div>
          <div class="row" style="gap:8px;">
            <button class="btn small" onclick="flowZoomIn()">üîç+ Zoom In</button>
            <button class="btn small" onclick="flowZoomOut()">üîç‚àí Zoom Out</button>
            <button class="btn small" onclick="flowFitToView()">‚ä° Fit to View</button>
            <button class="btn small" onclick="flowFontSizeIncrease()">A+ Text Larger</button>
            <button class="btn small" onclick="flowFontSizeDecrease()">A‚àí Text Smaller</button>
            <button class="btn small" onclick="flowReset()">‚Üª Reset</button>
          </div>
        </div>
      </div>
      <div class="bd" style="padding:0;position:relative;">
        <canvas id="flowCanvas" style="width:100%;height:900px;cursor:grab;touch-action:none;"></canvas>
        <div id="flowTooltip" style="
          position:absolute;
          display:none;
          background:rgba(16,26,48,0.95);
          border:1px solid rgba(255,255,255,0.2);
          border-radius:8px;
          padding:8px 12px;
          color:var(--text);
          font-size:12px;
          line-height:1.4;
          pointer-events:none;
          z-index:100;
          max-width:300px;
          box-shadow:0 4px 12px rgba(0,0,0,0.4);
          backdrop-filter:blur(8px);
        "></div>
      </div>
      <div class="hd" style="border-top:1px solid var(--border);border-bottom:none;">
        <div class="row" style="gap:16px;font-size:11px;flex-wrap:wrap;">
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--graph-group);border-radius:4px;"></span> Groups</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-challenge);border-radius:4px;"></span> Sub-Challenges</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-initiative);border-radius:4px;"></span> Initiatives</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-system);border-radius:4px;"></span> Systems</div>
          <div class="row" style="gap:4px;"><span style="display:inline-block;width:12px;height:12px;background:var(--c-kpi);border-radius:4px;"></span> KPIs</div>
          <span class="muted">|</span>
          <div class="muted">Flow thickness = relationship weight ‚Ä¢ Hover to see details ‚Ä¢ Click to filter</div>
        </div>
      </div>
    </div>
  </div>

</main>

<script>
// Data injected from Flask
const DATA = {"challengeGroups": [{"id": "C1", "number": 1, "priority": 1, "title": "Knowledge Acquisition"}, {"id": "C2", "number": 2, "priority": 1, "title": "Skill Development"}, {"id": "C3", "number": 3, "priority": 2, "title": "Community \u0026 Sharing"}], "initiatives": [{"challenges": [{"challengeId": "C1.SC1", "impact": "H", "weight": 10}, {"challengeId": "C1.SC3", "impact": "M", "weight": 5}], "id": "C1.I1", "raw": "Read 2 books per month - fiction and non-fiction alternating", "season": "S1", "text": "Read 2 books per month - fiction and non-fiction alternating"}, {"challenges": [{"challengeId": "C1.SC2", "impact": "H", "weight": 10}, {"challengeId": "C1.SC3", "impact": "M", "weight": 7}], "id": "C1.I2", "raw": "Create quarterly learning curriculum (pick 1-2 deep topics)", "season": "S1", "text": "Create quarterly learning curriculum (pick 1-2 deep topics)"}, {"challenges": [{"challengeId": "C1.SC3", "impact": "H", "weight": 10}], "id": "C1.I3", "raw": "Weekly digest - process saved articles on Sundays", "season": "S2", "text": "Weekly digest - process saved articles on Sundays"}, {"challenges": [{"challengeId": "C2.SC1", "impact": "H", "weight": 10}, {"challengeId": "C3.SC2", "impact": "M", "weight": 6}], "id": "C2.I1", "raw": "100 Days of Code - commit code daily on GitHub", "season": "S1", "text": "100 Days of Code - commit code daily on GitHub"}, {"challenges": [{"challengeId": "C2.SC2", "impact": "H", "weight": 10}], "id": "C2.I2", "raw": "Daily creative practice - 30 min sketching or music", "season": "S2", "text": "Daily creative practice - 30 min sketching or music"}, {"challenges": [{"challengeId": "C2.SC3", "impact": "H", "weight": 10}], "id": "C2.I3", "raw": "Duolingo streak - 15 min Spanish practice every morning", "season": "S2", "text": "Duolingo streak - 15 min Spanish practice every morning"}, {"challenges": [{"challengeId": "C3.SC1", "impact": "H", "weight": 10}, {"challengeId": "C2.SC1", "impact": "L", "weight": 5}], "id": "C3.I1", "raw": "Join online learning community (Discord/forum for main topic)", "season": "S1", "text": "Join online learning community (Discord/forum for main topic)"}, {"challenges": [{"challengeId": "C3.SC2", "impact": "H", "weight": 10}, {"challengeId": "C1.SC2", "impact": "M", "weight": 6}], "id": "C3.I2", "raw": "Start learning blog - publish monthly \"Today I Learned\" posts", "season": "S2", "text": "Start learning blog - publish monthly \"Today I Learned\" posts"}], "kpis": [{"id": "C1.K1", "systems": [{"systemId": "C1.S1", "weight": 10}], "text": "Read 24 books in one year"}, {"id": "C1.K2", "systems": [{"systemId": "C1.S2", "weight": 10}, {"systemId": "C2.S1", "weight": 8}], "text": "Complete 4 deep learning projects (one per quarter)"}, {"id": "C2.K1", "systems": [{"systemId": "C2.S1", "weight": 10}], "text": "Build and deploy 3 web apps from scratch"}, {"id": "C2.K2", "systems": [{"systemId": "C2.S2", "weight": 10}], "text": "Finish 100 drawings/sketches"}, {"id": "C2.K3", "systems": [{"systemId": "C2.S3", "weight": 10}], "text": "Achieve 365-day Duolingo streak"}, {"id": "C3.K1", "systems": [{"systemId": "C3.S1", "weight": 10}], "text": "Make 100 meaningful community contributions"}, {"id": "C3.K2", "systems": [{"systemId": "C3.S2", "weight": 10}], "text": "Publish 12 blog posts teaching what I learned"}, {"id": "C3.K3", "systems": [{"systemId": "C3.S1", "weight": 8}, {"systemId": "C3.S2", "weight": 10}], "text": "Help 10 people learn something new"}], "meta": {"generated": "2026-02-09T16:23:47.864035", "sourceDeck": "Staying Curious: Your Lifelong Learning Journey"}, "subChallenges": [{"groupId": "C1", "id": "C1.SC1", "priority": 1, "text": "Haven\u0027t read a book in 6 months - always scrolling social media"}, {"groupId": "C1", "id": "C1.SC2", "priority": 1, "text": "No structured learning plan - jumping between random topics"}, {"groupId": "C1", "id": "C1.SC3", "priority": 2, "text": "Information overload - saving articles but never reading them"}, {"groupId": "C2", "id": "C2.SC1", "priority": 1, "text": "Want to code but procrastinating on starting projects"}, {"groupId": "C2", "id": "C2.SC2", "priority": 2, "text": "Creative skills rusty - haven\u0027t drawn or made music in years"}, {"groupId": "C2", "id": "C2.SC3", "priority": 2, "text": "Language learning apps installed but never used"}, {"groupId": "C3", "id": "C3.SC1", "priority": 1, "text": "Learning in isolation - no discussion or accountability partners"}, {"groupId": "C3", "id": "C3.SC2", "priority": 2, "text": "Knowledge stays in head - not documenting or teaching others"}], "systems": [{"id": "C1.S1", "initiatives": [{"initiativeId": "C1.I1", "weight": 10}, {"initiativeId": "C1.I2", "weight": 7}], "text": "Reading System", "title": "Kindle + Goodreads tracking + book club membership"}, {"id": "C1.S2", "initiatives": [{"initiativeId": "C1.I3", "weight": 10}, {"initiativeId": "C1.I2", "weight": 8}], "text": "Content Curation", "title": "Pocket app + weekly review + tagging system"}, {"id": "C2.S1", "initiatives": [{"initiativeId": "C2.I1", "weight": 10}], "text": "Coding Practice", "title": "GitHub + LeetCode + freeCodeCamp curriculum"}, {"id": "C2.S2", "initiatives": [{"initiativeId": "C2.I2", "weight": 10}], "text": "Creative Tools", "title": "Procreate + GarageBand + daily practice timer"}, {"id": "C2.S3", "initiatives": [{"initiativeId": "C2.I3", "weight": 10}], "text": "Language Learning", "title": "Duolingo + Anki flashcards + Spanish podcast"}, {"id": "C3.S1", "initiatives": [{"initiativeId": "C3.I1", "weight": 10}, {"initiativeId": "C3.I2", "weight": 6}], "text": "Community Engagement", "title": "Discord server + Reddit communities + virtual meetups"}, {"id": "C3.S2", "initiatives": [{"initiativeId": "C3.I2", "weight": 10}], "text": "Knowledge Sharing", "title": "Blog (Ghost/Medium) + Twitter threads + teaching notes"}]};

const TABS = [
  {id:"challenges", label:"Challenges"},
  {id:"initiatives", label:"Initiatives"},
  {id:"systems", label:"Systems"},
  {id:"kpis", label:"KPIs"},
  {id:"workbench", label:"Workbench"},
];

let state = {
  tab: "challenges",
  selected: null,
  preview: null,
  initSeason: "ALL",
  workbench: { Challenges: [], Initiatives: [], Systems: [], KPIs: [] },
  viewMode: "column"  // "column" or "graph"
};

function byId(id) { return document.getElementById(id); }
function esc(s) {
  return (s ?? "").toString().replace(/[&<>"']/g, (m) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[m]));
}

function renderSeasonChip(showAll = false) {
  if (state.initSeason !== "ALL") {
    return `<span class="chip season mono">${esc(state.initSeason)}</span>`;
  }
  return showAll ? `<span class="chip mono">All seasons</span>` : "";
}

const groupById = Object.fromEntries(DATA.challengeGroups.map(g=>[g.id,g]));
const subById = Object.fromEntries(DATA.subChallenges.map(sc=>[sc.id,sc]));
const initById = Object.fromEntries(DATA.initiatives.map(i=>[i.id,i]));
const sysById = Object.fromEntries(DATA.systems.map(s=>[s.id,s]));
const kpiById = Object.fromEntries(DATA.kpis.map(k=>[k.id,k]));

function groupTitle(id) {
  const g = groupById[id];
  return g ? g.title : id;
}

function labelOf(type, obj) {
  if (!obj) return "";
  if (type==="challengeGroup") return obj.title || obj.id;
  if (type==="subChallenge") return obj.text || obj.id;
  if (type==="initiative") return obj.text || obj.raw || obj.id;
  if (type==="system") return obj.title || obj.text || obj.id;
  if (type==="kpi") return obj.text || obj.id;
  return obj.title || obj.text || obj.id || "";
}

/* --- Enhanced: Visual indicators --- */
function renderPriority(priority) {
  if (!priority) return "";
  const stars = { 1: '‚≠ê‚≠ê‚≠ê', 2: '‚≠ê‚≠ê', 3: '‚≠ê' };
  return `<span class="priority priority-${priority}" title="Priority ${priority}">${stars[priority] || ''}</span>`;
}

function renderImpact(impact) {
  if (!impact) return "";
  const labels = { H: 'High', M: 'Medium', L: 'Low' };
  return `<span class="impact impact-${impact}" title="${labels[impact]} Impact">${impact}</span>`;
}

function renderWeight(weight) {
  if (!weight) return "";
  return `<span class="weight" title="Weight: ${weight}/10">${weight}</span>`;
}

function renderWeightBar(weight) {
  if (!weight) return "";
  const percent = (weight / 10) * 100;
  return `<span class="weight-bar"><span class="weight-bar-fill" style="width:${percent}%"></span></span>`;
}

/* --- lightweight "best match" mapping --- */
function normWord(w){
  return w.toLowerCase().replace(/[^a-z0-9]+/g,"").trim();
}
function tokensFrom(text){
  const raw = (text||"").toLowerCase();
  const words = raw.split(/\s+/).map(normWord).filter(Boolean);
  const stop = new Set(["the","and","or","to","of","a","in","for","with","on","as","is","are","be","by","from","via","into","at","this","that","it","we","our","their","not","yet"]);
  return new Set(words.filter(w=>w.length>2 && !stop.has(w)));
}
const KEY_W = {
  "sap":6, "s4hana":6, "s4":6, "erp":6, "crm":6, "mes":6, "plm":6,
  "inventory":5, "wip":5, "leadtime":5, "delivery":5, "otd":5, "quality":5, "copq":5,
  "data":4, "masterdata":5, "mrp":5, "sop":5, "planning":5, "controltower":5, "exception":4,
  "traceability":5, "ecr":4, "eco":4, "engineering":4,
  "portal":4, "service":4, "remote":4, "predictive":4,
  "security":6, "mfa":6, "pam":6, "siem":6, "soc":5, "segmentation":5, "otit":6, "iot":6, "iiot":6, "edge":5, "5g":5,
  "cost":4, "margin":4, "variance":4, "licenses":4, "licence":4, "outsourcing":4, "managed":4, "sla":4,
  "governance":4, "adoption":4, "training":4, "change":4, "culture":4,
  "rto":5, "rpo":5, "backup":4, "dr":4
};

function extractTags(text){
  const t = (text||"").toLowerCase();
  const tags = new Set();
  const add = (x)=>tags.add(x);

  if (/lead[-\s]?time|cycle\s*time/.test(t)) add("leadtime");
  if (/on[-\s]?time|delivery|otd/.test(t)) add("otd");
  if (/inventory|wip|stock/.test(t)) add("inventory");
  if (/quality|copq|scrap|rework|trace/.test(t)) add("quality");
  if (/cost|margin|variance|transparency/.test(t)) add("cost");
  if (/crm|customer|portal|quote|pipeline/.test(t)) add("crm");
  if (/sap|s\/4|s4hana|erp/.test(t)) add("erp");
  if (/mes|shop[-\s]?floor|execution/.test(t)) add("mes");
  if (/plm|ecr|eco|engineering\s*change|bom|routing/.test(t)) add("plm");
  if (/data|master\s*data|single\s*version|truth/.test(t)) add("data");
  if (/integration|api|ipaas|interface|event/.test(t)) add("integration");
  if (/ot|iiot|iot|edge|sensor|5g|wifi/.test(t)) add("ot");
  if (/security|mfa|pam|siem|soc|segmentation|audit|gdpr|iso/.test(t)) add("security");
  if (/governance|decision|steer|pmo/.test(t)) add("governance");
  if (/adoption|training|change|culture|champion/.test(t)) add("adoption");
  if (/outsourc|managed\s*service|vendor|sla/.test(t)) add("sourcing");
  if (/backup|dr|rto|rpo|resilien/.test(t)) add("resilience");
  return tags;
}

function enrich(type, obj){
  const label = labelOf(type, obj);
  const text = label + " " + (obj.groupId ? groupTitle(obj.groupId) : "");
  obj._label = label;
  obj._tokens = tokensFrom(text);
  obj._tags = extractTags(text);
  return obj;
}

DATA.challengeGroups.forEach(g=>enrich("challengeGroup", g));
DATA.subChallenges.forEach(sc=>enrich("subChallenge", sc));
DATA.initiatives.forEach(i=>enrich("initiative", i));
DATA.systems.forEach(s=>enrich("system", s));
DATA.kpis.forEach(k=>enrich("kpi", k));

function intersectCount(aSet,bSet){
  let s=0;
  aSet.forEach(tok=>{ if(bSet.has(tok)) s += (KEY_W[tok] || 1); });
  return s;
}
function relScore(aItem,bItem){
  const tagOverlap = intersectCount(aItem._tags,bItem._tags);
  const tokScore = intersectCount(aItem._tokens,bItem._tokens);
  return tagOverlap*25 + tokScore;
}
function rankRelated(src, candidates, n){
  const scored = candidates.map(c=>({c, s: relScore(src,c)})).sort((x,y)=>y.s-x.s);
  const hasSignal = scored.length && scored[0].s>0;
  const filtered = hasSignal ? scored.filter(x=>x.s>0) : scored;
  const out = filtered.slice(0,n).map(x=>x.c);
  return out.length ? out : candidates.slice(0,n);
}

function setTab(tabId) {
  state.tab = tabId;
  for (const t of TABS) {
    const el = byId("tab-"+t.id);
    el.style.display = (t.id === tabId) ? "" : "none";
  }
  for (const btn of document.querySelectorAll(".tabbtn")) {
    btn.classList.toggle("active", btn.dataset.tab === tabId);
  }
  updateHash();
  renderFocusedDetail();
}

function renderTabs() {
  const host = byId("tabs");
  host.innerHTML = "";
  for (const t of TABS) {
    const b = document.createElement("button");
    b.className = "tabbtn" + (t.id===state.tab ? " active" : "");
    b.textContent = t.label;
    b.dataset.tab = t.id;
    b.onclick = () => setTab(t.id);
    host.appendChild(b);
  }
}

function updateHash(){
  const sel = (state.selected && inferTab(state.selected.type)===state.tab) ? `${state.selected.type}:${state.selected.id}` : "";
  history.replaceState(null, "", "#" + state.tab + (sel ? ("/"+sel) : ""));
}

function inferTab(type){
  if(type==="challengeGroup" || type==="subChallenge" || type==="challenge") return "challenges";
  if(type==="initiative") return "initiatives";
  if(type==="system") return "systems";
  if(type==="kpi") return "kpis";
  return "challenges";
}

function detailBodyIdForTab(tab){
  if(tab==="challenges") return "challengeDetailBody";
  if(tab==="initiatives") return "initiativeDetailBody";
  if(tab==="systems") return "systemDetailBody";
  if(tab==="kpis") return "kpiDetailBody";
  return null;
}

function renderByType(type,id){
  if(type==="challengeGroup") return renderChallengeGroupDetail(id);
  if(type==="subChallenge") return renderSubChallengeDetail(id);
  if(type==="initiative") return renderInitiativeDetail(id);
  if(type==="system") return renderSystemDetail(id);
  if(type==="kpi") return renderKpiDetail(id);
  return `<div class="card"><div class="muted">Nothing selected.</div></div>`;
}

function renderGlobalDetailForTab(tab){
  const seasonChip = renderSeasonChip(true);
  if(tab==="challenges"){
    const groups = DATA.challengeGroups.slice().sort((a,b)=>a.number-b.number);
    const subsCount = DATA.subChallenges.length;

    const allInits = [];
    const sysAllow = systemsTouchedBySeason();
    const kAllow = kpisTouchedBySeason();
    const allSys = [];
    const allK = [];

    for(const g of groups){
      seasonFilteredInits(g.id).forEach(i=>allInits.push(i));
      const sysAll = findSystems(g.id);
      const kAll = findKpis(g.id);
      sysAll.filter(s=>!sysAllow || sysAllow.has(s.id)).forEach(s=>allSys.push(s));
      kAll.filter(k=>!kAllow || kAllow.has(k.id)).forEach(k=>allK.push(k));
    }
    const dedup = (arr)=>Array.from(new Map(arr.map(x=>[x.id,x])).values());
    const inits = dedup(allInits);
    const sys = dedup(allSys);
    const ks = dedup(allK);

    const initsShown = inits;
    const sysShown = sys;
    const ksShown = ks;

    return `
      <div class="card">
        <div class="row" style="justify-content:space-between;">
          <div class="row"><h2 style="margin:0">Case map (all challenges)</h2>${seasonChip}</div>
          <button class="btn small" onclick="clearSelection()">Show all</button>
        </div>
        <div class="muted">Nothing selected ‚Äî full map view. Click any item to jump across.</div>

        <div class="hr"></div>
        <div class="row" style="gap:10px;flex-wrap:wrap">
          <span class="chip mono">${groups.length} challenges</span>
          <span class="chip mono">${subsCount} sub‚Äëchallenges</span>
          <span class="chip mono">${inits.length} initiatives</span>
          <span class="chip mono">${sys.length} systems</span>
          <span class="chip mono">${ks.length} KPIs</span>
        </div>

        <div class="hr"></div>
        <h3>Challenges</h3>
        <div class="pillwrap">
          ${groups.map(g=>`<span class="pill chall" onclick="jumpGroup('${g.id}')"><span class="badge mini ch mono">${esc(g.id)}</span> ${esc(g.title)}</span>`).join("")}
        </div>

        <div class="hr"></div>
        <h3>Initiatives (${inits.length})</h3>
        ${pillList(initsShown, "init", "jumpInit")}

        <div class="hr"></div>
        <h3>Systems touched (${sys.length})</h3>
        ${pillList(sysShown, "sys", "jumpSys")}

        <div class="hr"></div>
        <h3>KPIs (${ks.length})</h3>
        ${pillList(ksShown, "kpi", "jumpKpi")}
      </div>
    `;
  }

  const label = (tab==="initiatives") ? "initiative" : (tab==="systems") ? "system" : (tab==="kpis") ? "KPI" : "item";
  return `
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="row"><h2 style="margin:0">Nothing selected</h2>${seasonChip}</div>
        <button class="btn small" onclick="clearSelection()">Show all</button>
      </div>
      <div class="muted">Use search + the left list to select a ${label}. (Season filter applies globally.)</div>
    </div>
  `;
}

function renderFocusedDetail(){
  const bodyId = detailBodyIdForTab(state.tab);
  if(!bodyId) return;
  const host = byId(bodyId);
  if(!host) return;

  const focus = state.preview || (state.selected && inferTab(state.selected.type)===state.tab ? state.selected : null);
  let inner = "";

  if(!focus){
    inner = renderGlobalDetailForTab(state.tab);
  } else {
    inner = renderByType(focus.type, focus.id);
    if(state.preview){
      inner = `
        <div class="card" style="border-style:dashed;margin-bottom:10px">
          <div class="row" style="justify-content:space-between;">
            <div class="row"><span class="chip mono">Preview</span><span class="muted">Right‚Äëpane click ‚Äî left selection unchanged.</span></div>
            <div class="row" style="gap:8px">
              <button class="btn small primary" onclick="openPreview()">Open</button>
              <button class="btn small" onclick="clearPreview()">Back</button>
            </div>
          </div>
        </div>
      ` + inner;
    }
  }

  host.innerHTML = inner;
}

function clearPreview(){ state.preview = null; renderFocusedDetail(); }
function openPreview(){
  if(!state.preview) return;
  const p = state.preview;
  select(p.type, p.id, {autoTab: inferTab(p.type)});
}
function preview(type,id){
  if (type==="challenge") type = id.includes(".SC") ? "subChallenge" : "challengeGroup";
  if(state.preview && state.preview.type===type && state.preview.id===id){
    state.preview = null;
  } else {
    state.preview = {type,id};

    // Clear graph and flow selections so preview will propagate
    if (graph.canvas) {
      graph.selectedNode = null;
      graph.filteredNodes = null;
      graph.filteredLinks = null;
    }
    if (flow.canvas) {
      flow.selectedNode = null;
      flow.filteredNodes = null;
      flow.filteredLinks = null;
    }
  }
  renderFocusedDetail();
}

function clearSelection(){
  state.selected = null;
  state.preview = null;
  document.querySelectorAll("[data-key].active").forEach(el=>el.classList.remove("active"));
  renderFocusedDetail();
  updateHash();

  // Reset Graph view filter
  if (graph.canvas) {
    graph.selectedNode = null;
    graph.filteredNodes = null;
    graph.filteredLinks = null;
    renderGraph();
    updateGraphUI();
  }

  // Reset Flow view filter
  if (flow.canvas) {
    flow.selectedNode = null;
    flow.filteredNodes = null;
    flow.filteredLinks = null;
    layoutFlowDiagram(); // Re-layout to show all nodes
    drawFlowDiagram();
  }
}

function select(type, id, {autoTab=null, forceSelect=false}={}) {
  console.log('select() called - type:', type, 'id:', id, 'forceSelect:', forceSelect, 'current state.selected:', state.selected ? `${state.selected.type} ${state.selected.id}` : 'none');

  if (type==="challenge") type = id.includes(".SC") ? "subChallenge" : "challengeGroup";

  // Toggle off if already selected (unless forceSelect is true)
  if (!forceSelect && state.selected && state.selected.type===type && state.selected.id===id) {
    console.log('Same item already selected - toggling off');
    clearSelection();
    return;
  }

  console.log('Setting state.selected to:', type, id);
  state.selected = {type, id};
  state.preview = null;
  if (autoTab) setTab(autoTab);

  document.querySelectorAll("[data-key].active").forEach(el=>el.classList.remove("active"));
  const el = document.querySelector(`[data-key="${type}:${id}"]`);
  if (el) el.classList.add("active");

  renderFocusedDetail();
  updateHash();

  // Clear graph and flow selections so new column selection will propagate
  // when user switches to those views
  // BUT: Don't clear if isSyncing is true - that means we're syncing FROM graph/flow
  // to column view, and the filters are already correctly set
  if (!isSyncing) {
    if (graph.canvas) {
      graph.selectedNode = null;
      graph.filteredNodes = null;
      graph.filteredLinks = null;
    }
    if (flow.canvas) {
      flow.selectedNode = null;
      flow.filteredNodes = null;
      flow.filteredLinks = null;
    }
  }

  // Sync with graph view if it's currently active AND not already syncing
  if (state.viewMode === 'graph' && !isSyncing) {
    console.log('Select called with:', type, id, 'viewMode:', state.viewMode);
    syncColumnToGraphView(type, id);
  }

  // Sync with flow view if it's currently active AND not already syncing
  if (state.viewMode === 'flow' && !isSyncing) {
    console.log('Select called - syncing to flow view:', type, id);
    setTimeout(() => {
      syncColumnToFlowView(type, id);
    }, 10);
  }
}

function findSubs(groupId) {
  return DATA.subChallenges.filter(sc => sc.groupId === groupId);
}

function findInits(challengeId) {
  // Check if this is a challenge group (e.g., "C1") or sub-challenge (e.g., "C1.SC1")
  const isGroup = !challengeId.includes(".SC");

  if (isGroup) {
    // For challenge group: find initiatives linked to ANY of its sub-challenges
    const subs = findSubs(challengeId);
    const subIds = subs.map(sc => sc.id);

    const enhanced = DATA.initiatives.filter(i =>
      i.challenges && i.challenges.some(link => subIds.includes(link.challengeId))
    );
    if (enhanced.length > 0) return enhanced;

    // Legacy format: use groupId
    return DATA.initiatives.filter(i => i.groupId === challengeId || i.legacyGroupId === challengeId);
  } else {
    // For sub-challenge: find initiatives linked to this specific sub-challenge
    const enhanced = DATA.initiatives.filter(i =>
      i.challenges && i.challenges.some(link => link.challengeId === challengeId)
    );
    if (enhanced.length > 0) return enhanced;

    // Legacy format: use groupId (extract group from sub-challenge ID)
    const groupId = challengeId.split(".")[0];
    return DATA.initiatives.filter(i => i.groupId === groupId || i.legacyGroupId === groupId);
  }
}

function findSystemsForInitiatives(initiativeIds) {
  // Enhanced format: find systems that link to these initiatives
  return DATA.systems.filter(s =>
    s.initiatives && s.initiatives.some(link => initiativeIds.includes(link.initiativeId))
  );
}

function findSystems(challengeOrGroupId) {
  // Enhanced format: find systems through initiatives
  const inits = findInits(challengeOrGroupId);
  if (inits.length > 0) {
    const initIds = inits.map(i => i.id);
    return findSystemsForInitiatives(initIds);
  }

  // Legacy format: use groupId
  return DATA.systems.filter(s => s.groupId === challengeOrGroupId || s.legacyGroupId === challengeOrGroupId);
}

function findKpisForSystems(systemIds) {
  // Enhanced format: find KPIs that link to these systems
  return DATA.kpis.filter(k =>
    k.systems && k.systems.some(link => systemIds.includes(link.systemId))
  );
}

function findKpis(challengeOrGroupId) {
  // Enhanced format: find KPIs through systems
  const systems = findSystems(challengeOrGroupId);
  if (systems.length > 0) {
    const sysIds = systems.map(s => s.id);
    return findKpisForSystems(sysIds);
  }

  // Legacy format: use groupId
  return DATA.kpis.filter(k => k.groupId === challengeOrGroupId || k.legacyGroupId === challengeOrGroupId);
}

function seasonFilteredInits(groupId) {
  const all = findInits(groupId);
  if (state.initSeason==="ALL") return all;
  return all.filter(i=>i.season===state.initSeason);
}
function unionRelated(fromItems, candidates, topN) {
  const m = new Map();
  for (const it of (fromItems||[])) {
    const rel = rankRelated(it, candidates, topN);
    for (const c of rel) m.set(c.id, c);
  }
  return Array.from(m.values());
}
function systemsTouchedBySeason() {
  if (state.initSeason==="ALL") return null;
  const allow = new Set();
  for (const g of DATA.challengeGroups) {
    const inits = seasonFilteredInits(g.id);
    if (!inits.length) continue;
    const sysAll = findSystems(g.id);
    unionRelated(inits, sysAll, 3).forEach(s=>allow.add(s.id));
  }
  return allow;
}
function kpisTouchedBySeason() {
  if (state.initSeason==="ALL") return null;
  const allow = new Set();
  for (const g of DATA.challengeGroups) {
    const inits = seasonFilteredInits(g.id);
    if (!inits.length) continue;
    const kAll = findKpis(g.id);
    unionRelated(inits, kAll, 3).forEach(k=>allow.add(k.id));
  }
  return allow;
}

function pillList(items, kind, onClickFn) {
  if (!items.length) return `<span class="muted">None</span>`;
  return `<div class="pillwrap">` + items.map(it => {
    const label = esc(labelOf(kind, it));
    return `<span class="pill ${kind}" onclick="${onClickFn}('${it.id}')">${label}</span>`;
  }).join("") + `</div>`;
}

function jumpGroup(id) { preview("challengeGroup", id); }
function jumpSub(id) { preview("subChallenge", id); }
function jumpInit(id) { preview("initiative", id); }
function jumpSys(id) { preview("system", id); }
function jumpKpi(id) { preview("kpi", id); }

function renderChallengeGroupDetail(groupId) {
  const g = groupById[groupId];
  if(!g) return `<div class="card"><div class="muted">Select a challenge.</div></div>`;
  const subs = findSubs(groupId);

  const initsPool = findInits(groupId);
  const sysAll = findSystems(groupId);
  const kpisAll = findKpis(groupId);

  const inits = (state.initSeason==="ALL") ? initsPool : initsPool.filter(i=>i.season===state.initSeason);
  let sys = sysAll;
  let kpis = kpisAll;

  if (state.initSeason!=="ALL") {
    const sysCand = unionRelated(inits, sysAll, 3);
    const kCand = unionRelated(inits, kpisAll, 3);
    if (sysCand.length) sys = sysCand;
    if (kCand.length) kpis = kCand;
  }

  const seasonChip = renderSeasonChip();

  return `
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row"><span class="badge ch mono">${esc(g.id)}</span><h2 style="margin:0">${esc(g.title)}</h2>${seasonChip}</div>
        <button class="btn small" onclick="pin('Challenges','challengeGroup','${g.id}')">Pin</button>
      </div>
      <div class="muted">Parent challenge overview ‚Äî click any sub‚Äëchallenge to zoom in.</div>

      <div class="hr"></div>
      <h3>Sub‚Äëchallenges (${subs.length})</h3>
      <div class="pillwrap">
        ${subs.map(sc=>`<span class="pill chall" onclick="jumpSub('${sc.id}')">${esc(sc.text)}</span>`).join("")}
      </div>

      <div class="hr"></div>
      <h3>Initiatives (${inits.length})</h3>
      ${pillList(inits, "init", "jumpInit")}

      <div class="hr"></div>
      <h3>Systems (${sys.length})</h3>
      ${pillList(sys, "sys", "jumpSys")}

      <div class="hr"></div>
      <h3>KPIs (${kpis.length})</h3>
      ${pillList(kpis, "kpi", "jumpKpi")}
    </div>
  `;
}

function renderSubChallengeDetail(subId) {
  const sc = subById[subId];
  if(!sc) return `<div class="card"><div class="muted">Select a sub‚Äëchallenge.</div></div>`;
  const g = groupById[sc.groupId];

  const initsPool = findInits(sc.groupId);
  const initsAll = seasonFilteredInits(sc.groupId);
  const sysAll = findSystems(sc.groupId);
  const kAll = findKpis(sc.groupId);

  const inits = rankRelated(sc, initsAll, 5);

  let sys = rankRelated(sc, sysAll, 5);
  let ks = rankRelated(sc, kAll, 5);

  if (state.initSeason!=="ALL") {
    const sysCand = unionRelated(inits, sysAll, 3);
    const kCand = unionRelated(inits, kAll, 3);
    if (sysCand.length) sys = rankRelated(sc, sysCand, 5);
    if (kCand.length) ks = rankRelated(sc, kCand, 5);
  }

  const seasonChip = renderSeasonChip();

  const poolNote = (state.initSeason==="ALL") ? `${inits.length} of ${initsPool.length}` : `${inits.length} of ${initsAll.length} (${esc(state.initSeason)})`;

  return `
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row"><span class="badge ch mono">${esc(g.id)}</span><span class="muted">Sub‚Äëchallenge</span>${seasonChip}</div>
        <button class="btn small" onclick="pin('Challenges','subChallenge','${sc.id}')">Pin</button>
      </div>

      <h2>${esc(sc.text)}</h2>

      <div class="hr"></div>
      <h3>Most relevant initiatives</h3>
      ${pillList(inits, "init", "jumpInit")}
      <div class="muted" style="font-size:11.5px;margin-top:6px">(${poolNote})</div>

      <div class="hr"></div>
      <h3>Enabling systems</h3>
      ${pillList(sys, "sys", "jumpSys")}

      <div class="hr"></div>
      <h3>How we measure it</h3>
      ${pillList(ks, "kpi", "jumpKpi")}

      <div class="hr"></div>
      <button class="btn small" onclick="jumpGroup('${g.id}')">Back to ${g.id} overview</button>
    </div>
  `;
}

function renderInitiativeDetail(initId) {
  const it = initById[initId];
  if(!it) return `<div class="card"><div class="muted">Select an initiative.</div></div>`;

  // Enhanced format: get linked challenges
  let subs = [];
  let challengeGroupId = null;
  if (it.challenges && it.challenges.length > 0) {
    // Enhanced format
    subs = it.challenges.map(link => subById[link.challengeId]).filter(Boolean);
    if (subs.length > 0 && subs[0].groupId) {
      challengeGroupId = subs[0].groupId;
    }
  } else if (it.groupId || it.legacyGroupId) {
    // Legacy format
    challengeGroupId = it.groupId || it.legacyGroupId;
    const subsAll = findSubs(challengeGroupId);
    subs = rankRelated(it, subsAll, 5);
  }

  // Get systems linked to this initiative
  let sys = [];
  if (it.challenges && it.challenges.length > 0) {
    // Enhanced format: find systems that link to this initiative
    sys = DATA.systems.filter(s =>
      s.initiatives && s.initiatives.some(link => link.initiativeId === it.id)
    );
  } else if (challengeGroupId) {
    // Legacy format
    const sysAll = findSystems(challengeGroupId);
    sys = rankRelated(it, sysAll, 6);
  }

  // Get KPIs linked to those systems
  let ks = [];
  if (sys.length > 0) {
    const sysIds = sys.map(s => s.id);
    ks = DATA.kpis.filter(k =>
      k.systems && k.systems.some(link => sysIds.includes(link.systemId))
    );
    if (ks.length === 0 && challengeGroupId) {
      // Legacy fallback
      const kAll = findKpis(challengeGroupId);
      ks = rankRelated(it, kAll, 6);
    }
  } else if (challengeGroupId) {
    // Legacy format
    const kAll = findKpis(challengeGroupId);
    ks = rankRelated(it, kAll, 6);
  }

  const g = challengeGroupId ? groupById[challengeGroupId] : null;
  const groupBadge = g ? `<span class="badge in mono">${esc(g.id)}</span>` : "";
  const season = it.season ? `<span class="chip season mono">${esc(it.season)}</span>` : "";
  const backButton = g ? `<button class="btn small" onclick="jumpGroup('${g.id}')">Back to ${g.id}</button>` : "";

  return `
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row">${groupBadge}${season}</div>
        <button class="btn small" onclick="pin('Initiatives','initiative','${it.id}')">Pin</button>
      </div>
      <h2>${esc(it.raw || it.text)}</h2>

      <div class="hr"></div>
      <h3>Sub‚Äëchallenges it addresses (${subs.length})</h3>
      <div class="pillwrap">
        ${subs.length > 0 ? subs.map(sc=>`<span class="pill chall" onclick="jumpSub('${sc.id}')">${esc(sc.text)}</span>`).join("") : '<span class="muted">None found</span>'}
      </div>

      <div class="hr"></div>
      <h3>Systems we use / build (${sys.length})</h3>
      ${sys.length > 0 ? pillList(sys, "sys", "jumpSys") : '<span class="muted">None found</span>'}

      <div class="hr"></div>
      <h3>KPIs this should move (${ks.length})</h3>
      ${ks.length > 0 ? pillList(ks, "kpi", "jumpKpi") : '<span class="muted">None found</span>'}

      ${backButton ? `<div class="hr"></div>${backButton}` : ""}
    </div>
  `;
}

function renderSystemDetail(sysId) {
  const s = sysById[sysId];
  if(!s) return `<div class="card"><div class="muted">Select a system.</div></div>`;

  // Enhanced format: get linked initiatives
  let inits = [];
  let challengeGroupId = null;
  if (s.initiatives && s.initiatives.length > 0) {
    // Enhanced format
    inits = s.initiatives.map(link => initById[link.initiativeId]).filter(Boolean);
    // Apply season filter
    if (state.initSeason !== "ALL") {
      inits = inits.filter(i => i.season === state.initSeason);
    }
    // Get group from first initiative's challenges
    if (inits.length > 0 && inits[0].challenges && inits[0].challenges.length > 0) {
      const firstChallenge = subById[inits[0].challenges[0].challengeId];
      if (firstChallenge) challengeGroupId = firstChallenge.groupId;
    }
  } else if (s.groupId || s.legacyGroupId) {
    // Legacy format
    challengeGroupId = s.groupId || s.legacyGroupId;
    const initsAll = seasonFilteredInits(challengeGroupId);
    inits = rankRelated(s, initsAll, 6);
  }

  // Get sub-challenges from initiatives
  let subs = [];
  if (inits.length > 0) {
    const subSet = new Set();
    inits.forEach(i => {
      if (i.challenges && i.challenges.length > 0) {
        i.challenges.forEach(link => {
          const sc = subById[link.challengeId];
          if (sc) subSet.add(sc);
        });
      }
    });
    subs = Array.from(subSet);
    if (subs.length === 0 && challengeGroupId) {
      // Legacy fallback
      const subsAll = findSubs(challengeGroupId);
      subs = rankRelated(s, subsAll, 5);
    }
  } else if (challengeGroupId) {
    // Legacy format
    const subsAll = findSubs(challengeGroupId);
    subs = rankRelated(s, subsAll, 5);
  }

  // Get KPIs linked to this system
  let ks = [];
  if (s.initiatives && s.initiatives.length > 0) {
    // Enhanced format: find KPIs that link to this system
    ks = DATA.kpis.filter(k =>
      k.systems && k.systems.some(link => link.systemId === s.id)
    );
  } else if (challengeGroupId) {
    // Legacy format
    const kAll = findKpis(challengeGroupId);
    ks = rankRelated(s, kAll, 6);
  }

  const g = challengeGroupId ? groupById[challengeGroupId] : null;
  const groupBadge = g ? `<span class="badge sy mono">${esc(g.id)}</span>` : "";
  const seasonChip = renderSeasonChip();
  const backButton = g ? `<button class="btn small" onclick="jumpGroup('${g.id}')">Back to ${g.id}</button>` : "";
  const bullets = (s.bullets && s.bullets.length) ? `<ul>${s.bullets.map(b=>`<li>${esc(b)}</li>`).join("")}</ul>` : "";

  return `
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row">${groupBadge}<span class="muted">System</span>${seasonChip}</div>
        <button class="btn small" onclick="pin('Systems','system','${s.id}')">Pin</button>
      </div>
      <h2>${esc(labelOf("system", s))}</h2>
      ${bullets}

      <div class="hr"></div>
      <h3>Initiatives enabled (${inits.length})</h3>
      ${inits.length > 0 ? pillList(inits, "init", "jumpInit") : '<span class="muted">None found</span>'}

      <div class="hr"></div>
      <h3>Sub‚Äëchallenges where it matters (${subs.length})</h3>
      <div class="pillwrap">
        ${subs.length > 0 ? subs.map(sc=>`<span class="pill chall" onclick="jumpSub('${sc.id}')">${esc(sc.text)}</span>`).join("") : '<span class="muted">None found</span>'}
      </div>

      <div class="hr"></div>
      <h3>KPIs we expect to move (${ks.length})</h3>
      ${ks.length > 0 ? pillList(ks, "kpi", "jumpKpi") : '<span class="muted">None found</span>'}

      ${backButton ? `<div class="hr"></div>${backButton}` : ""}
    </div>
  `;
}

function renderKpiDetail(kpiId) {
  const k = kpiById[kpiId];
  if(!k) return `<div class="card"><div class="muted">Select a KPI.</div></div>`;

  // Enhanced format: get linked systems
  let sys = [];
  let challengeGroupId = null;
  if (k.systems && k.systems.length > 0) {
    // Enhanced format
    sys = k.systems.map(link => sysById[link.systemId]).filter(Boolean);
  } else if (k.groupId || k.legacyGroupId) {
    // Legacy format
    challengeGroupId = k.groupId || k.legacyGroupId;
    const sysAll = findSystems(challengeGroupId);
    sys = rankRelated(k, sysAll, 6);
  }

  // Get initiatives from systems
  let inits = [];
  if (sys.length > 0) {
    const initSet = new Set();
    sys.forEach(s => {
      if (s.initiatives && s.initiatives.length > 0) {
        s.initiatives.forEach(link => {
          const init = initById[link.initiativeId];
          if (init) initSet.add(init);
        });
      }
    });
    inits = Array.from(initSet);
    // Apply season filter
    if (state.initSeason !== "ALL") {
      inits = inits.filter(i => i.season === state.initSeason);
    }
    // Get group from first initiative
    if (inits.length > 0 && inits[0].challenges && inits[0].challenges.length > 0) {
      const firstChallenge = subById[inits[0].challenges[0].challengeId];
      if (firstChallenge) challengeGroupId = firstChallenge.groupId;
    }
    if (inits.length === 0 && challengeGroupId) {
      // Legacy fallback
      const initsAll = seasonFilteredInits(challengeGroupId);
      inits = rankRelated(k, initsAll, 6);
    }
  } else if (challengeGroupId) {
    // Legacy format
    const initsAll = seasonFilteredInits(challengeGroupId);
    inits = rankRelated(k, initsAll, 6);
  }

  // Get sub-challenges from initiatives
  let subs = [];
  if (inits.length > 0) {
    const subSet = new Set();
    inits.forEach(i => {
      if (i.challenges && i.challenges.length > 0) {
        i.challenges.forEach(link => {
          const sc = subById[link.challengeId];
          if (sc) subSet.add(sc);
        });
      }
    });
    subs = Array.from(subSet);
    if (subs.length === 0 && challengeGroupId) {
      // Legacy fallback
      const subsAll = findSubs(challengeGroupId);
      subs = rankRelated(k, subsAll, 5);
    }
  } else if (challengeGroupId) {
    // Legacy format
    const subsAll = findSubs(challengeGroupId);
    subs = rankRelated(k, subsAll, 5);
  }

  const g = challengeGroupId ? groupById[challengeGroupId] : null;
  const groupBadge = g ? `<span class="badge kp mono">${esc(g.id)}</span>` : "";
  const seasonChip = renderSeasonChip();
  const backButton = g ? `<button class="btn small" onclick="jumpGroup('${g.id}')">Back to ${g.id}</button>` : "";

  return `
    <div class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row">${groupBadge}<span class="muted">KPI</span>${seasonChip}</div>
        <button class="btn small" onclick="pin('KPIs','kpi','${k.id}')">Pin</button>
      </div>
      <h2>${esc(k.text)}</h2>

      <div class="hr"></div>
      <h3>Systems that influence this KPI (${sys.length})</h3>
      ${sys.length > 0 ? pillList(sys, "sys", "jumpSys") : '<span class="muted">None found</span>'}

      <div class="hr"></div>
      <h3>Initiatives that drive it (${inits.length})</h3>
      ${inits.length > 0 ? pillList(inits, "init", "jumpInit") : '<span class="muted">None found</span>'}

      <div class="hr"></div>
      <h3>Sub‚Äëchallenges behind the KPI (${subs.length})</h3>
      <div class="pillwrap">
        ${subs.length > 0 ? subs.map(sc=>`<span class="pill chall" onclick="jumpSub('${sc.id}')">${esc(sc.text)}</span>`).join("") : '<span class="muted">None found</span>'}
      </div>

      ${backButton ? `<div class="hr"></div>${backButton}` : ""}
    </div>
  `;
}

function renderChallengeTree() {
  const host = byId("challengeTree");
  host.innerHTML = "";
  const q = (byId("searchChallenges").value || "").toLowerCase().trim();

  for (const g of DATA.challengeGroups.slice().sort((a,b)=>a.number-b.number)) {
    const subs = findSubs(g.id);
    const matchesGroup = (g.title || "").toLowerCase().includes(q) || g.id.toLowerCase().includes(q);
    const matchesSubs = subs.filter(sc => (sc.text||"").toLowerCase().includes(q));
    if (q && !matchesGroup && matchesSubs.length===0) continue;

    const d = document.createElement("details");
    d.open = false;
    if (q && (matchesGroup || matchesSubs.length)) d.open = true;

    const s = document.createElement("summary");
    s.setAttribute("data-key", `challengeGroup:${g.id}`);
    s.innerHTML = `<span class="row" style="gap:8px"><span class="chip group mono">${esc(g.id)}</span><span>${esc(g.title)}</span>${renderPriority(g.priority)}</span><span class="chip mono">${subs.length} sub</span>`;
    s.addEventListener("click", ()=>{ select("challengeGroup", g.id, {autoTab:"challenges"}); });
    d.appendChild(s);

    const subDiv = document.createElement("div");
    subDiv.className = "sub";
    const showSubs = q ? matchesSubs : subs;
    for (const sc of showSubs) {
      const div = document.createElement("div");
      div.className = "subitem";
      div.setAttribute("data-key", `subChallenge:${sc.id}`);
      div.innerHTML = `${esc(sc.text)}${renderPriority(sc.priority)}`;
      div.onclick = () => select("subChallenge", sc.id, {autoTab:"challenges"});
      subDiv.appendChild(div);
    }
    d.appendChild(subDiv);

    host.appendChild(d);
  }
}

function setInitSeason(season) {
  state.initSeason = season;
  document.querySelectorAll('[data-season]').forEach(b=>{
    b.classList.toggle('primary', b.dataset.season===season);
  });
  renderInitiativeList();
  renderSystemList();
  renderKpiList();
  renderFocusedDetail();

  // Update graph view if it's active
  if (state.viewMode === 'graph' && graph.canvas) {
    // Clear selection when season changes
    graph.selectedNode = null;
    graph.filteredNodes = null;
    graph.filteredLinks = null;
    graph.history = [];

    // Rebuild and redraw graph
    const { nodes, links } = buildGraphData();
    graph.nodes = nodes;
    graph.links = links;
    layoutGraph();
    drawGraph();
    updateGraphUI();
  }

  // Update flow view if it's initialized
  if (flow.canvas) {
    // Clear selection when season changes
    flow.selectedNode = null;
    flow.filteredNodes = null;
    flow.filteredLinks = null;

    // Rebuild and redraw flow
    buildFlowData();
    layoutFlowDiagram();
    drawFlowDiagram();
    updateFlowUI();
  }
}

function renderInitiativeList() {
  const host = byId("initiativeList");
  if (!host) return;

  const searchInput = byId("searchInitiatives");
  const q = searchInput ? (searchInput.value || "").toLowerCase().trim() : "";
  host.innerHTML = "";

  let items = DATA.initiatives ? DATA.initiatives.slice() : [];

  // Season filter
  if (state.initSeason !== "ALL") {
    items = items.filter(i => i.season === state.initSeason);
  }

  // Search filter
  if (q) {
    items = items.filter(i => {
      const text = (i.raw || i.text || "").toLowerCase();
      if (text.includes(q)) return true;

      // Check linked challenges
      if (i.challenges && Array.isArray(i.challenges)) {
        return i.challenges.some(link => {
          const sc = subById[link.challengeId];
          return sc && (sc.text.toLowerCase().includes(q) || sc.id.toLowerCase().includes(q));
        });
      }

      // Legacy format
      if (i.groupId || i.legacyGroupId) {
        const gid = i.groupId || i.legacyGroupId;
        return groupTitle(gid).toLowerCase().includes(q);
      }
      return false;
    });
  }

  // Sort
  items.sort((a,b)=> {
    const sa = a.season || "S9";
    const sb = b.season || "S9";
    if (sa !== sb) return sa.localeCompare(sb);

    const aKey = (a.challenges && a.challenges.length > 0) ? a.challenges[0].challengeId : (a.groupId || a.legacyGroupId || a.id);
    const bKey = (b.challenges && b.challenges.length > 0) ? b.challenges[0].challengeId : (b.groupId || b.legacyGroupId || b.id);
    return aKey.localeCompare(bKey);
  });

  // Render items
  for (const i of items) {
    const div = document.createElement("div");
    div.className = "item";
    div.setAttribute("data-key", `initiative:${i.id}`);
    div.onclick = () => select("initiative", i.id, {autoTab:"initiatives"});

    // Build badges
    let badges = "";
    if (i.challenges && i.challenges.length > 0) {
      badges = i.challenges.slice(0, 3).map(link => {
        const impact = link.impact ? ` <span class="impact impact-${link.impact}">${link.impact}</span>` : "";
        const weight = link.weight ? ` <span class="weight">${link.weight}</span>` : "";
        return `<span class="chip group mono">${esc(link.challengeId)}${impact}${weight}</span>`;
      }).join(" ");
      if (i.challenges.length > 3) badges += ` <span class="chip">+${i.challenges.length - 3}</span>`;
    } else if (i.groupId || i.legacyGroupId) {
      badges = `<span class="chip group mono">${esc(i.groupId || i.legacyGroupId)}</span>`;
    }

    const description = i.challenges && i.challenges.length > 0
      ? `${i.challenges.length} challenge(s)`
      : (i.groupId ? esc(groupTitle(i.groupId)) : "");

    div.innerHTML = `
      <div class="row" style="justify-content: space-between;">
        <div class="t">${esc(i.raw || i.text)}</div>
        <div class="row" style="gap:4px;flex-wrap:wrap;">
          ${i.season ? `<span class="chip season mono">${esc(i.season)}</span>` : ""}
          ${badges}
        </div>
      </div>
      ${description ? `<div class="m">${description}</div>` : ""}
    `;
    host.appendChild(div);
  }
}

function renderSystemList() {
  const host = byId("systemList");
  if (!host) return;

  const searchInput = byId("searchSystems");
  const q = searchInput ? (searchInput.value || "").toLowerCase().trim() : "";
  host.innerHTML = "";

  let items = DATA.systems ? DATA.systems.slice() : [];

  // Search filter
  if (q) {
    items = items.filter(s => {
      const text = labelOf("system", s).toLowerCase();
      if (text.includes(q)) return true;

      // Check linked initiatives
      if (s.initiatives && Array.isArray(s.initiatives)) {
        return s.initiatives.some(link => {
          const init = initById[link.initiativeId];
          return init && ((init.text || "").toLowerCase().includes(q) || init.id.toLowerCase().includes(q));
        });
      }

      // Legacy format
      if (s.groupId || s.legacyGroupId) {
        const gid = s.groupId || s.legacyGroupId;
        return groupTitle(gid).toLowerCase().includes(q);
      }
      return false;
    });
  }

  // Season filter
  if (state.initSeason !== "ALL") {
    const allow = systemsTouchedBySeason();
    if (allow) items = items.filter(s => allow.has(s.id));
  }

  // Sort
  items.sort((a,b)=> {
    const aKey = (a.initiatives && a.initiatives.length > 0) ? a.initiatives[0].initiativeId : (a.groupId || a.legacyGroupId || a.id);
    const bKey = (b.initiatives && b.initiatives.length > 0) ? b.initiatives[0].initiativeId : (b.groupId || b.legacyGroupId || b.id);
    return aKey.localeCompare(bKey);
  });

  // Render items
  for (const s of items) {
    const div = document.createElement("div");
    div.className = "item";
    div.setAttribute("data-key", `system:${s.id}`);
    div.onclick = () => select("system", s.id, {autoTab:"systems"});

    // Build badges
    let badges = "";
    if (s.initiatives && s.initiatives.length > 0) {
      badges = s.initiatives.slice(0, 3).map(link => {
        const weight = link.weight ? ` <span class="weight">${link.weight}</span>` : "";
        return `<span class="chip group mono">${esc(link.initiativeId)}${weight}</span>`;
      }).join(" ");
      if (s.initiatives.length > 3) badges += ` <span class="chip">+${s.initiatives.length - 3}</span>`;
    } else if (s.groupId || s.legacyGroupId) {
      badges = `<span class="chip group mono">${esc(s.groupId || s.legacyGroupId)}</span>`;
    }

    const description = s.initiatives && s.initiatives.length > 0
      ? `${s.initiatives.length} initiative(s)`
      : (s.groupId ? esc(groupTitle(s.groupId)) : "");

    div.innerHTML = `
      <div class="row" style="justify-content: space-between;">
        <div class="t">${esc(labelOf("system", s))}</div>
        <div class="row" style="gap:4px;flex-wrap:wrap;">${badges}</div>
      </div>
      ${description ? `<div class="m">${description}</div>` : ""}
    `;
    host.appendChild(div);
  }
}

function renderKpiList() {
  const host = byId("kpiList");
  if (!host) return;

  const searchInput = byId("searchKpis");
  const q = searchInput ? (searchInput.value || "").toLowerCase().trim() : "";
  host.innerHTML = "";

  let items = DATA.kpis ? DATA.kpis.slice() : [];

  // Search filter
  if (q) {
    items = items.filter(k => {
      const text = (k.text || "").toLowerCase();
      if (text.includes(q)) return true;

      // Check linked systems
      if (k.systems && Array.isArray(k.systems)) {
        return k.systems.some(link => {
          const sys = sysById[link.systemId];
          return sys && (labelOf("system", sys).toLowerCase().includes(q) || sys.id.toLowerCase().includes(q));
        });
      }

      // Legacy format
      if (k.groupId || k.legacyGroupId) {
        const gid = k.groupId || k.legacyGroupId;
        return groupTitle(gid).toLowerCase().includes(q);
      }
      return false;
    });
  }

  // Season filter
  if (state.initSeason !== "ALL") {
    const allow = kpisTouchedBySeason();
    if (allow) items = items.filter(k => allow.has(k.id));
  }

  // Sort
  items.sort((a,b)=> {
    const aKey = (a.systems && a.systems.length > 0) ? a.systems[0].systemId : (a.groupId || a.legacyGroupId || a.id);
    const bKey = (b.systems && b.systems.length > 0) ? b.systems[0].systemId : (b.groupId || b.legacyGroupId || b.id);
    return aKey.localeCompare(bKey);
  });

  // Render items
  for (const k of items) {
    const div = document.createElement("div");
    div.className = "item";
    div.setAttribute("data-key", `kpi:${k.id}`);
    div.onclick = () => select("kpi", k.id, {autoTab:"kpis"});

    // Build badges
    let badges = "";
    if (k.systems && k.systems.length > 0) {
      badges = k.systems.slice(0, 3).map(link => {
        const weight = link.weight ? ` <span class="weight">${link.weight}</span>` : "";
        return `<span class="chip group mono">${esc(link.systemId)}${weight}</span>`;
      }).join(" ");
      if (k.systems.length > 3) badges += ` <span class="chip">+${k.systems.length - 3}</span>`;
    } else if (k.groupId || k.legacyGroupId) {
      badges = `<span class="chip group mono">${esc(k.groupId || k.legacyGroupId)}</span>`;
    }

    const description = k.systems && k.systems.length > 0
      ? `${k.systems.length} system(s)`
      : (k.groupId ? esc(groupTitle(k.groupId)) : "");

    div.innerHTML = `
      <div class="row" style="justify-content: space-between;">
        <div class="t">${esc(k.text)}</div>
        <div class="row" style="gap:4px;flex-wrap:wrap;">${badges}</div>
      </div>
      ${description ? `<div class="m">${description}</div>` : ""}
    `;
    host.appendChild(div);
  }
}

/* --- Workbench --- */
function pin(colName, type, id) {
  let obj=null;
  if(type==="challengeGroup") obj = groupById[id];
  if(type==="subChallenge") obj = subById[id];
  if(type==="initiative") obj = initById[id];
  if(type==="system") obj = sysById[id];
  if(type==="kpi") obj = kpiById[id];
  if(!obj) return;

  const label = (type==="subChallenge") ? obj.text : labelOf(type,obj);
  state.workbench[colName].push({type, id, label});
  renderWorkbench();
}

function moveCard(col, idx, dir) {
  const arr = state.workbench[col];
  const j = idx + dir;
  if (j < 0 || j >= arr.length) return;
  const tmp = arr[idx]; arr[idx] = arr[j]; arr[j] = tmp;
  renderWorkbench();
}
function removeCard(col, idx) {
  state.workbench[col].splice(idx,1);
  renderWorkbench();
}

function renderWorkbench() {
  const host = byId("kanban");
  host.innerHTML = "";
  const cols = ["Challenges","Initiatives","Systems","KPIs"];
  for (const c of cols) {
    const div = document.createElement("div");
    div.className = "col";
    div.innerHTML = `<h3>${c}</h3>`;
    for (let i=0;i<state.workbench[c].length;i++) {
      const card = state.workbench[c][i];
      const el = document.createElement("div");
      el.className = "wcard";
      el.draggable = true;
      el.ondragstart = (ev)=>{ ev.dataTransfer.setData("text/plain", JSON.stringify({col:c, idx:i})); };
      el.innerHTML = `
        <div class="t">${esc(card.label)}</div>
        <div class="m mono">${esc(card.type)}:${esc(card.id)}</div>
        <div class="actions">
          <button class="btn small primary" onclick="select('${card.type}','${card.id}',{autoTab: inferTab('${card.type}')})">Open</button>
          <button class="btn small" onclick="moveCard('${c}',${i},-1)">‚Üë</button>
          <button class="btn small" onclick="moveCard('${c}',${i},1)">‚Üì</button>
          <button class="btn small" onclick="removeCard('${c}',${i})">Remove</button>
        </div>
      `;
      div.appendChild(el);
    }
    div.ondragover = (ev)=>{ ev.preventDefault(); };
    div.ondrop = (ev)=>{
      ev.preventDefault();
      try {
        const src = JSON.parse(ev.dataTransfer.getData("text/plain"));
        const card = state.workbench[src.col][src.idx];
        state.workbench[src.col].splice(src.idx,1);
        state.workbench[c].push(card);
        renderWorkbench();
      } catch(e) {}
    };
    host.appendChild(div);
  }
}

function saveWorkbench() {
  localStorage.setItem("mNavigatorWorkbench", JSON.stringify(state.workbench));
  alert("Workbench saved in this browser.");
}
function loadWorkbench() {
  const raw = localStorage.getItem("mNavigatorWorkbench");
  if (!raw) return alert("No saved workbench found.");
  try { state.workbench = JSON.parse(raw); renderWorkbench(); } catch(e) { alert("Could not load saved state."); }
}
function clearWorkbench() {
  state.workbench = {Challenges:[],Initiatives:[],Systems:[],KPIs:[]};
  renderWorkbench();
}

function initFromHash() {
  const h = (location.hash || "").replace(/^#/, "");
  if (!h) return;
  const parts = h.split("/");
  const tab = parts[0];
  if (TABS.some(t=>t.id===tab)) setTab(tab);
  if (parts[1]) {
    const [type, id] = parts[1].split(":");
    if (type && id) select(type, id, {autoTab: inferTab(type)});
  }
}

function wireSearch() {
  byId("searchChallenges").addEventListener("input", renderChallengeTree);
  byId("searchInitiatives").addEventListener("input", renderInitiativeList);
  byId("searchSystems").addEventListener("input", renderSystemList);
  byId("searchKpis").addEventListener("input", renderKpiList);
}

/* ========================================
   VIEW MODE TOGGLE
   ======================================== */
function setViewMode(mode) {
  state.viewMode = mode;
  const columnView = byId('columnView');
  const graphView = byId('graphView');
  const flowView = byId('flowView');
  const btnColumn = byId('btnColumnView');
  const btnGraph = byId('btnGraphView');
  const btnFlow = byId('btnFlowView');

  if (mode === 'flow') {
    columnView.style.display = 'none';
    graphView.style.display = 'none';
    flowView.style.display = 'block';
    btnColumn.classList.remove('primary');
    btnGraph.classList.remove('primary');
    btnFlow.classList.add('primary');

    // Initialize flow if not already done
    if (!flow.canvas) {
      console.log('Initializing flow view for first time');
      initFlowView();
    }

    // Priority order for syncing to flow view:
    // 1. Graph view selection (if user was in graph and clicked something)
    // 2. Column view selection (if user selected something in column view)
    // 3. No selection - show full flow

    if (graph.canvas && graph.selectedNode) {
      // Sync from graph view selection
      console.log('Flow view: Syncing from graph selection:', graph.selectedNode.entityId);
      setTimeout(() => {
        if (flow.canvas) {
          syncGraphToFlowView();
        } else {
          console.error('Flow canvas not ready after init!');
        }
      }, 50); // Increased timeout to ensure flow is ready
    } else {
      // Sync from column view selection
      const itemToSync = state.preview || state.selected;
      if (itemToSync) {
        console.log('Flow view: Syncing from column selection:', itemToSync.type, itemToSync.id);
        setTimeout(() => {
          syncColumnToFlowView(itemToSync.type, itemToSync.id);
        }, 50);
      } else {
        // No selection, show full flow
        console.log('Flow view: Showing full unfiltered view');
        flow.selectedNode = null;
        flow.filteredNodes = null;
        flow.filteredLinks = null;
        if (flow.canvas) {
          layoutFlowDiagram();
          drawFlowDiagram();
          updateFlowUI();
        }
      }
    }
  } else if (mode === 'graph') {
    columnView.style.display = 'none';
    graphView.style.display = 'block';
    flowView.style.display = 'none';
    btnColumn.classList.remove('primary');
    btnGraph.classList.add('primary');
    btnFlow.classList.remove('primary');

    console.log('=== SWITCHING TO GRAPH VIEW ===');
    console.log('state.selected:', state.selected);
    console.log('state.preview:', state.preview);
    console.log('graph.canvas exists:', !!graph.canvas);
    console.log('graph.selectedNode:', graph.selectedNode ? graph.selectedNode.id : 'none');
    console.log('flow.selectedNode:', flow.selectedNode ? flow.selectedNode.id : 'none');

    // Initialize graph if not already done
    if (!graph.canvas) {
      console.log('First time - rendering graph');
      renderGraph();
    }

    // Priority order for syncing to graph view:
    // 1. Graph view already has selection (preserve it when returning)
    // 2. Flow view selection (if user was in flow and clicked something)
    // 3. Column view selection (if user selected something in column view)
    // 4. No selection - show full graph

    if (graph.selectedNode) {
      // Graph already has a selection, redraw and fit to view
      console.log('Graph already has selection, keeping it:', graph.selectedNode.id);
      drawGraph();
      // Auto-fit to view to ensure selection is visible
      setTimeout(() => {
        graphFitToView();
      }, 10);
    } else if (flow.canvas && flow.selectedNode) {
      // Sync from flow view selection
      console.log('Graph view: Syncing from flow selection:', flow.selectedNode.id);
      setTimeout(() => {
        syncFlowToGraphView();
      }, 10);
    } else {
      // Check for column selection or preview
      const itemToSync = state.preview || state.selected;
      if (itemToSync) {
        console.log('Switching to graph view with item:', itemToSync.type, itemToSync.id);
        setTimeout(() => {
          console.log('About to call syncColumnToGraphView with:', itemToSync.type, itemToSync.id);
          syncColumnToGraphView(itemToSync.type, itemToSync.id);
        }, 10);
      } else {
        console.log('No selection anywhere - rendering full graph');
        // No selection, just render the full graph
        renderGraph();
      }
    }
  } else {
    columnView.style.display = 'block';
    graphView.style.display = 'none';
    flowView.style.display = 'none';
    btnColumn.classList.add('primary');
    btnGraph.classList.remove('primary');
    btnFlow.classList.remove('primary');

    console.log('Switching to column view');
    console.log('Current state.selected:', state.selected ? `${state.selected.type} ${state.selected.id}` : 'none');
    console.log('graph.selectedNode:', graph.selectedNode ? graph.selectedNode.entityId : 'none');
    console.log('flow.selectedNode:', flow.selectedNode ? flow.selectedNode.id : 'none');

    // Sync from graph or flow to column if there's a selection that differs from column
    if (!isSyncing) {
      if (graph.selectedNode) {
        const graphEntityId = graph.selectedNode.entityId;
        const columnEntityId = state.selected ? state.selected.id : null;
        if (graphEntityId !== columnEntityId) {
          console.log('Column view: Syncing from graph selection');
          syncGraphToColumnView(graph.selectedNode);
        }
      } else if (flow.selectedNode) {
        const flowEntityId = flow.selectedNode.id;
        const columnEntityId = state.selected ? state.selected.id : null;
        if (flowEntityId !== columnEntityId) {
          console.log('Column view: Syncing from flow selection');
          const columnType = flow.selectedNode.type === 'challengeGroup' ? 'challengeGroup' :
                             flow.selectedNode.type === 'challenge' ? 'subChallenge' :
                             flow.selectedNode.type;
          const autoTab = flow.selectedNode.type === 'challengeGroup' || flow.selectedNode.type === 'challenge' ? 'challenges' :
                          flow.selectedNode.type === 'initiative' ? 'initiatives' :
                          flow.selectedNode.type === 'system' ? 'systems' : 'kpis';

          isSyncing = true;
          try {
            select(columnType, flow.selectedNode.id, {forceSelect: true, autoTab: autoTab});
          } finally {
            isSyncing = false;
          }
        }
      }
    }
  }
}

/* ========================================
   GRAPH VIEW - Canvas-based Visualization
   ======================================== */
let graph = {
  canvas: null,
  ctx: null,
  nodes: [],
  links: [],
  zoom: 1,
  panX: 0,
  panY: 0,
  dragging: null,
  hovering: null,
  selectedNode: null,  // Currently selected node for filtering
  filteredNodes: null, // Set of visible node IDs when filtered
  filteredLinks: null, // Set of visible links when filtered
  history: [],         // Navigation history stack for back button
  fontSize: 1.0        // Font size multiplier (0.8, 1.0, 1.2, 1.5, 2.0)
};

// Get colors from CSS variables
function getColor(varName) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

const COLORS = {
  group: getColor('--graph-group'),
  challenge: getColor('--c-challenge'),
  initiative: getColor('--c-initiative'),
  system: getColor('--c-system'),
  kpi: getColor('--c-kpi')
};

function buildGraphData() {
  const nodes = [];
  const links = [];

  // Create nodes for challenge groups
  const challengeGroupNodes = {};
  DATA.challengeGroups.forEach(g => {
    const node = {
      id: `group-${g.id}`,
      entityId: g.id,
      type: 'group',
      label: `${g.id}: ${g.title}`,
      fullLabel: g.title,
      priority: g.priority || 2,
      x: 0,
      y: 0,
      width: 200,
      height: 50,
      color: COLORS.group
    };
    nodes.push(node);
    challengeGroupNodes[g.id] = node;
  });

  // Create nodes for sub-challenges
  const challengeNodes = {};
  DATA.subChallenges.forEach(sc => {
    const node = {
      id: `challenge-${sc.id}`,
      entityId: sc.id,
      type: 'challenge',
      label: `${sc.id.split('.')[1]}: ${sc.text.substring(0, 30)}${sc.text.length > 30 ? '...' : ''}`,
      fullLabel: sc.text,
      priority: sc.priority || 2,
      groupId: sc.groupId,
      x: 0,
      y: 0,
      width: 180,
      height: 50,
      color: COLORS.challenge
    };
    nodes.push(node);
    challengeNodes[sc.id] = node;

    // Create link from group to sub-challenge
    const groupNode = challengeGroupNodes[sc.groupId];
    if (groupNode) {
      links.push({
        source: groupNode,
        target: node,
        weight: 10,
        type: 'group-challenge'
      });
    }
  });

  // Create nodes for initiatives (with season filtering)
  const initiativeNodes = {};
  let filteredInitiatives = DATA.initiatives;

  // Apply season filter
  if (state.initSeason !== "ALL") {
    filteredInitiatives = DATA.initiatives.filter(i => i.season === state.initSeason);
  }

  filteredInitiatives.forEach(init => {
    const node = {
      id: `initiative-${init.id}`,
      entityId: init.id,
      type: 'initiative',
      label: `${init.id}: ${init.text.substring(0, 30)}${init.text.length > 30 ? '...' : ''}`,
      fullLabel: init.text,
      season: init.season,
      x: 0,
      y: 0,
      width: 180,
      height: 50,
      color: COLORS.initiative
    };
    nodes.push(node);
    initiativeNodes[init.id] = node;

    // Create links from challenges to initiatives (top to bottom)
    if (init.challenges && init.challenges.length > 0) {
      init.challenges.forEach(link => {
        const challengeNode = challengeNodes[link.challengeId];
        if (challengeNode) {
          links.push({
            source: challengeNode,
            target: node,
            weight: link.weight || 5,
            impact: link.impact || 'M',
            type: 'challenge-initiative'
          });
        }
      });
    }
  });

  // Create nodes for systems
  const systemNodes = {};
  DATA.systems.forEach(sys => {
    const label = sys.title || sys.text || sys.id;
    const node = {
      id: `system-${sys.id}`,
      entityId: sys.id,
      type: 'system',
      label: `${sys.id}: ${label.substring(0, 30)}${label.length > 30 ? '...' : ''}`,
      fullLabel: label,
      x: 0,
      y: 0,
      width: 180,
      height: 50,
      color: COLORS.system
    };
    nodes.push(node);
    systemNodes[sys.id] = node;

    // Create links from initiatives to systems (top to bottom)
    if (sys.initiatives && sys.initiatives.length > 0) {
      sys.initiatives.forEach(link => {
        const initiativeNode = initiativeNodes[link.initiativeId];
        if (initiativeNode) {
          links.push({
            source: initiativeNode,
            target: node,
            weight: link.weight || 5,
            type: 'initiative-system'
          });
        }
      });
    }
  });

  // Create nodes for KPIs
  DATA.kpis.forEach(kpi => {
    const node = {
      id: `kpi-${kpi.id}`,
      entityId: kpi.id,
      type: 'kpi',
      label: `${kpi.id}: ${kpi.text.substring(0, 30)}${kpi.text.length > 30 ? '...' : ''}`,
      fullLabel: kpi.text,
      x: 0,
      y: 0,
      width: 180,
      height: 50,
      color: COLORS.kpi
    };
    nodes.push(node);

    // Create links from systems to KPIs (top to bottom)
    if (kpi.systems && kpi.systems.length > 0) {
      kpi.systems.forEach(link => {
        const systemNode = systemNodes[link.systemId];
        if (systemNode) {
          links.push({
            source: systemNode,
            target: node,
            weight: link.weight || 5,
            type: 'system-kpi'
          });
        }
      });
    }
  });

  // If season filter is active, only include nodes that are connected
  if (state.initSeason !== "ALL") {
    const connectedNodeIds = new Set();

    // Add all initiative nodes
    Object.values(initiativeNodes).forEach(node => {
      connectedNodeIds.add(node.id);
    });

    // Add connected challenges and groups
    links.forEach(link => {
      if (link.type === 'challenge-initiative') {
        connectedNodeIds.add(link.source.id);
        // Add parent group
        const challengeNode = link.source;
        links.forEach(groupLink => {
          if (groupLink.type === 'group-challenge' && groupLink.target.id === challengeNode.id) {
            connectedNodeIds.add(groupLink.source.id);
          }
        });
      }
    });

    // Add connected systems
    links.forEach(link => {
      if (link.type === 'initiative-system') {
        connectedNodeIds.add(link.target.id);
      }
    });

    // Add connected KPIs
    links.forEach(link => {
      if (link.type === 'system-kpi' && connectedNodeIds.has(link.source.id)) {
        connectedNodeIds.add(link.target.id);
      }
    });

    // Filter nodes to only include connected ones
    const filteredNodes = nodes.filter(node => connectedNodeIds.has(node.id));
    const filteredLinks = links.filter(link =>
      connectedNodeIds.has(link.source.id) && connectedNodeIds.has(link.target.id)
    );

    return { nodes: filteredNodes, links: filteredLinks };
  }

  return { nodes, links };
}

function renderGraph() {
  const canvas = byId('graphCanvas');
  if (!canvas) return;

  graph.canvas = canvas;
  graph.ctx = canvas.getContext('2d');

  // Set actual canvas size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  graph.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  // Build graph data
  const { nodes, links } = buildGraphData();
  graph.nodes = nodes;
  graph.links = links;

  // Initial layout - spread vertically per column
  layoutGraph();

  // Draw
  drawGraph();

  // Setup interactions
  setupGraphInteractions();

  // Update UI
  updateGraphUI();
}

function layoutGraph() {
  // Vertical layout: rows from top to bottom
  // Groups at top, then challenges, then initiatives, then systems, then KPIs
  const rows = {
    group: { y: 60, nodes: [] },
    challenge: { y: 150, nodes: [] },
    initiative: { y: 270, nodes: [] },
    system: { y: 390, nodes: [] },
    kpi: { y: 510, nodes: [] }
  };

  // Filter nodes if there's a selection
  let visibleNodes = graph.nodes;
  if (graph.selectedNode && graph.filteredNodes) {
    visibleNodes = graph.nodes.filter(n => graph.filteredNodes.has(n.id));
  }

  visibleNodes.forEach(node => {
    rows[node.type].nodes.push(node);
  });

  // Position nodes in rows with horizontal spacing
  Object.values(rows).forEach(row => {
    const horizontalSpacing = 220;
    const rowNodes = row.nodes;
    const totalWidth = rowNodes.length * horizontalSpacing;
    const startX = Math.max(100, (1200 - totalWidth) / 2); // Center or start at 100

    rowNodes.forEach((node, i) => {
      node.x = startX + i * horizontalSpacing;
      node.y = row.y;
    });
  });
}

function drawGraph() {
  const ctx = graph.ctx;
  const canvas = graph.canvas;

  // Clear
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Apply transformations
  ctx.save();
  ctx.translate(graph.panX, graph.panY);
  ctx.scale(graph.zoom, graph.zoom);

  // Draw links first
  graph.links.forEach(link => {
    drawLink(link);
  });

  // Draw nodes
  graph.nodes.forEach(node => {
    drawNode(node);
  });

  ctx.restore();
}

function drawLink(link) {
  // Skip if this link is filtered out
  if (graph.filteredLinks && !graph.filteredLinks.has(link)) {
    return;
  }

  const ctx = graph.ctx;
  const weight = link.weight || 5;
  const thickness = weight; // Direct weight-to-thickness: 1-10px

  // Draw line from bottom of source to top of target (vertical flow)
  const sourceX = link.source.x;
  const sourceY = link.source.y + link.source.height / 2;
  const targetX = link.target.x;
  const targetY = link.target.y - link.target.height / 2;

  // Bezier curve for smoother vertical flow
  const midY = (sourceY + targetY) / 2;

  ctx.beginPath();
  ctx.moveTo(sourceX, sourceY);
  ctx.bezierCurveTo(sourceX, midY, targetX, midY, targetX, targetY);

  // Color based on link type
  if (link.type === 'group-challenge') {
    ctx.strokeStyle = `rgba(251, 191, 36, ${0.4 + weight / 25})`; // Brighter yellow for group links
  } else if (link.type === 'challenge-initiative') {
    ctx.strokeStyle = `rgba(240, 210, 79, ${0.4 + weight / 25})`;
  } else if (link.type === 'initiative-system') {
    ctx.strokeStyle = `rgba(143, 208, 255, ${0.4 + weight / 25})`;
  } else {
    ctx.strokeStyle = `rgba(34, 197, 94, ${0.4 + weight / 25})`;
  }

  ctx.lineWidth = thickness;
  ctx.stroke();
}

function drawNode(node) {
  // Skip if this node is filtered out
  if (graph.filteredNodes && !graph.filteredNodes.has(node.id)) {
    return;
  }

  const ctx = graph.ctx;
  const w = node.width;
  const h = node.height;
  const x = node.x - w / 2;
  const y = node.y - h / 2;
  const radius = 12;

  // Determine if selected
  const isSelected = graph.selectedNode && graph.selectedNode.id === node.id;
  const isHovered = graph.hovering === node;

  // Draw rounded rectangle
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + w - radius, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
  ctx.lineTo(x + w, y + h - radius);
  ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
  ctx.lineTo(x + radius, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();

  // Fill with color
  ctx.fillStyle = node.color;
  ctx.fill();

  // Border
  if (isSelected) {
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.stroke();
  } else if (isHovered) {
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();
  } else if (node.priority === 1) {
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2;
    ctx.stroke();
  } else {
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

  // Draw label text inside
  ctx.fillStyle = '#1a1a1a';
  const baseFontSize = 10;
  const fontSize = Math.round(baseFontSize * graph.fontSize);
  ctx.font = `bold ${fontSize}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Wrap text if needed
  const maxWidth = w - 10;
  const lines = wrapText(ctx, node.label, maxWidth);
  const baseLineHeight = 12;
  const lineHeight = baseLineHeight * graph.fontSize;
  const totalHeight = lines.length * lineHeight;
  const startY = node.y - totalHeight / 2 + lineHeight / 2;

  lines.forEach((line, i) => {
    ctx.fillText(line, node.x, startY + i * lineHeight);
  });
}

function wrapText(ctx, text, maxWidth) {
  const words = text.split(' ');
  const lines = [];
  let currentLine = words[0];

  for (let i = 1; i < words.length; i++) {
    const testLine = currentLine + ' ' + words[i];
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth) {
      lines.push(currentLine);
      currentLine = words[i];
    } else {
      currentLine = testLine;
    }
  }
  lines.push(currentLine);
  return lines.slice(0, 3); // Max 3 lines
}

function updateTooltip(node, mouseX, mouseY) {
  const tooltip = document.getElementById('graphTooltip');

  if (!node || !node.fullLabel) {
    // Hide tooltip
    tooltip.style.display = 'none';
    return;
  }

  // Show tooltip with full label
  tooltip.textContent = node.fullLabel;
  tooltip.style.display = 'block';

  // Position tooltip near cursor
  const offsetX = 15;
  const offsetY = 15;
  const canvas = document.getElementById('graphCanvas');
  const canvasRect = canvas.getBoundingClientRect();

  // Calculate position relative to canvas container
  let tooltipX = mouseX - canvasRect.left + offsetX;
  let tooltipY = mouseY - canvasRect.top + offsetY;

  // Keep tooltip within canvas bounds
  const tooltipRect = tooltip.getBoundingClientRect();
  if (tooltipX + tooltipRect.width > canvasRect.width) {
    tooltipX = mouseX - canvasRect.left - tooltipRect.width - offsetX;
  }
  if (tooltipY + tooltipRect.height > canvasRect.height) {
    tooltipY = mouseY - canvasRect.top - tooltipRect.height - offsetY;
  }

  tooltip.style.left = tooltipX + 'px';
  tooltip.style.top = tooltipY + 'px';
}

function setupGraphInteractions() {
  const canvas = graph.canvas;
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let clickStart = { x: 0, y: 0, time: 0 };
  let nodeClickHandled = false; // Flag to prevent double handling

  canvas.addEventListener('mousedown', (e) => {
    nodeClickHandled = false; // Reset on each mousedown
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - graph.panX) / graph.zoom;
    const y = (e.clientY - rect.top - graph.panY) / graph.zoom;

    clickStart = { x: e.clientX, y: e.clientY, time: Date.now() };

    // Check if clicking on a node
    const node = findNodeAt(x, y);
    if (node) {
      graph.dragging = node;
    } else {
      isDragging = true;
      dragStart = { x: e.clientX - graph.panX, y: e.clientY - graph.panY };
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - graph.panX) / graph.zoom;
    const y = (e.clientY - rect.top - graph.panY) / graph.zoom;

    if (graph.dragging) {
      graph.dragging.x = x;
      graph.dragging.y = y;
      updateTooltip(null); // Hide tooltip when dragging
      drawGraph();
    } else if (isDragging) {
      graph.panX = e.clientX - dragStart.x;
      graph.panY = e.clientY - dragStart.y;
      updateTooltip(null); // Hide tooltip when panning
      drawGraph();
    } else {
      // Hover detection
      const node = findNodeAt(x, y);
      if (node !== graph.hovering) {
        graph.hovering = node;
        canvas.style.cursor = node ? 'pointer' : 'grab';
        drawGraph();
      }
      // Update tooltip position and content
      updateTooltip(node, e.clientX, e.clientY);
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    const timeDiff = Date.now() - clickStart.time;
    const distMoved = Math.sqrt(
      Math.pow(e.clientX - clickStart.x, 2) + Math.pow(e.clientY - clickStart.y, 2)
    );

    // If it's a quick click without much movement, treat as node selection
    if (timeDiff < 300 && distMoved < 5) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - graph.panX) / graph.zoom;
      const y = (e.clientY - rect.top - graph.panY) / graph.zoom;
      const node = findNodeAt(x, y);

      if (node) {
        nodeClickHandled = true; // Mark that we're handling a node click
        selectGraphNode(node);
      }
      // Note: Clicking empty space no longer clears selection
    }

    graph.dragging = null;
    isDragging = false;
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseleave', () => {
    graph.dragging = null;
    isDragging = false;
    graph.hovering = null;
    canvas.style.cursor = 'grab';
    updateTooltip(null); // Hide tooltip when mouse leaves canvas
    drawGraph();
  });

  // Touch support for mobile devices
  let touches = [];
  let lastTouchDistance = 0;
  let touchStart = { x: 0, y: 0, time: 0 };

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // Prevent page zoom
    touches = Array.from(e.touches);

    if (touches.length === 1) {
      // Single touch - prepare for pan or node selection
      const touch = touches[0];
      const rect = canvas.getBoundingClientRect();
      touchStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now()
      };

      const x = (touch.clientX - rect.left - graph.panX) / graph.zoom;
      const y = (touch.clientY - rect.top - graph.panY) / graph.zoom;

      // Check if touching a node
      const node = findNodeAt(x, y);
      if (node) {
        graph.dragging = node;
      } else {
        isDragging = true;
        dragStart = { x: touch.clientX - graph.panX, y: touch.clientY - graph.panY };
      }
    } else if (touches.length === 2) {
      // Two fingers - pinch to zoom
      isDragging = false;
      graph.dragging = null;
      lastTouchDistance = getTouchDistance(touches[0], touches[1]);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); // Prevent page zoom
    touches = Array.from(e.touches);

    if (touches.length === 1 && (graph.dragging || isDragging)) {
      // Single touch - pan or drag node
      const touch = touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = (touch.clientX - rect.left - graph.panX) / graph.zoom;
      const y = (touch.clientY - rect.top - graph.panY) / graph.zoom;

      if (graph.dragging) {
        graph.dragging.x = x;
        graph.dragging.y = y;
      } else if (isDragging) {
        graph.panX = touch.clientX - dragStart.x;
        graph.panY = touch.clientY - dragStart.y;
      }
      drawGraph();
    } else if (touches.length === 2) {
      // Two fingers - pinch to zoom
      const currentDistance = getTouchDistance(touches[0], touches[1]);

      if (lastTouchDistance > 0) {
        const scaleFactor = currentDistance / lastTouchDistance;
        const oldZoom = graph.zoom;
        graph.zoom *= scaleFactor;
        graph.zoom = Math.max(0.3, Math.min(3, graph.zoom));

        // Zoom towards the center of the two touch points
        const rect = canvas.getBoundingClientRect();
        const centerX = (touches[0].clientX + touches[1].clientX) / 2 - rect.left;
        const centerY = (touches[0].clientY + touches[1].clientY) / 2 - rect.top;

        // Adjust pan to keep zoom centered
        const zoomChange = graph.zoom / oldZoom;
        graph.panX = centerX - (centerX - graph.panX) * zoomChange;
        graph.panY = centerY - (centerY - graph.panY) * zoomChange;

        drawGraph();
      }

      lastTouchDistance = currentDistance;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault(); // Prevent page zoom

    const timeDiff = Date.now() - touchStart.time;

    // If it was a quick tap without much movement, treat as node selection
    if (touches.length === 1 && timeDiff < 300) {
      const touch = touches[0];
      const distMoved = Math.sqrt(
        Math.pow(touch.clientX - touchStart.x, 2) +
        Math.pow(touch.clientY - touchStart.y, 2)
      );

      if (distMoved < 10) {
        const rect = canvas.getBoundingClientRect();
        const x = (touch.clientX - rect.left - graph.panX) / graph.zoom;
        const y = (touch.clientY - rect.top - graph.panY) / graph.zoom;
        const node = findNodeAt(x, y);

        if (node) {
          selectGraphNode(node);
        }
      }
    }

    touches = Array.from(e.touches);
    if (touches.length === 0) {
      graph.dragging = null;
      isDragging = false;
      lastTouchDistance = 0;
    } else if (touches.length === 1) {
      // Went from 2 fingers to 1 - reset for panning
      lastTouchDistance = 0;
      const touch = touches[0];
      dragStart = { x: touch.clientX - graph.panX, y: touch.clientY - graph.panY };
    }
  }, { passive: false });

  // Helper function to calculate distance between two touches
  function getTouchDistance(touch1, touch2) {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Mouse wheel zoom for desktop
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const oldZoom = graph.zoom;
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    graph.zoom *= delta;
    graph.zoom = Math.max(0.3, Math.min(3, graph.zoom));

    // Zoom towards mouse cursor position
    const zoomChange = graph.zoom / oldZoom;
    graph.panX = mouseX - (mouseX - graph.panX) * zoomChange;
    graph.panY = mouseY - (mouseY - graph.panY) * zoomChange;

    drawGraph();
  }, { passive: false });
}

function findNodeAt(x, y) {
  // Check rectangles instead of circles
  for (let node of graph.nodes) {
    // Skip if filtered out
    if (graph.filteredNodes && !graph.filteredNodes.has(node.id)) {
      continue;
    }

    const left = node.x - node.width / 2;
    const right = node.x + node.width / 2;
    const top = node.y - node.height / 2;
    const bottom = node.y + node.height / 2;

    if (x >= left && x <= right && y >= top && y <= bottom) {
      return node;
    }
  }
  return null;
}

function selectGraphNode(node) {
  console.log('=== selectGraphNode called ===');
  console.log('node:', node);
  console.log('node.id:', node.id);
  console.log('node.type:', node.type);
  console.log('node.entityId:', node.entityId);
  console.log('graph.selectedNode:', graph.selectedNode);

  // Set flag to prevent clearGraphSelection from running immediately after
  graph.nodeSelectionInProgress = true;

  // Note: We don't deselect when clicking the same node anymore
  // This allows navigation like: Initiative A ‚Üí System B ‚Üí Initiative A
  // Users can use the Back button to clear selection

  // Save current state to history before changing
  if (graph.selectedNode || graph.filteredNodes) {
    console.log('Saving history');
    graph.history.push({
      selectedNode: graph.selectedNode,
      filteredNodes: graph.filteredNodes ? new Set(graph.filteredNodes) : null,
      filteredLinks: graph.filteredLinks ? new Set(graph.filteredLinks) : null
    });
  }

  // Map graph node type to column view type
  let type = node.type;
  let id = node.entityId;

  if (type === 'group') type = 'challengeGroup';
  else if (type === 'challenge') type = 'subChallenge';

  console.log('selectGraphNode - calling syncColumnToGraphView with type:', type, 'id:', id);

  // Use the exact same filtering logic as when clicking in column view
  // This ensures consistent behavior between column and graph view clicks
  syncColumnToGraphView(type, id);

  // Also sync back to column view to update the selection state in the sidebar
  if (!isSyncing) {
    console.log('selectGraphNode - syncing back to column view');
    syncGraphToColumnView(node);
  }

  console.log('=== selectGraphNode done ===');

  // Clear the flag after a short delay to allow any pending events to complete
  setTimeout(() => {
    graph.nodeSelectionInProgress = false;
  }, 100);
}

function clearGraphSelection() {
  console.log('=== clearGraphSelection called ===');
  console.log('graph.nodeSelectionInProgress:', graph.nodeSelectionInProgress);
  console.trace('Stack trace:');

  // Don't clear if a node selection is currently in progress
  if (graph.nodeSelectionInProgress) {
    console.log('Ignoring clearGraphSelection - node selection in progress');
    return;
  }

  // Don't add to history when clearing
  graph.selectedNode = null;
  graph.filteredNodes = null;
  graph.filteredLinks = null;
  graph.history = []; // Clear history when going back to full view
  layoutGraph();
  drawGraph();
  updateGraphUI();

  // DON'T clear column view selection - keep column and graph views independent
  console.log('Graph selection cleared - column view selection preserved');
}

function graphGoBack() {
  if (graph.history.length === 0) {
    // No history - go to full view
    clearGraphSelection();
    return;
  }

  // Pop the last state from history
  const previousState = graph.history.pop();
  graph.selectedNode = previousState.selectedNode;
  graph.filteredNodes = previousState.filteredNodes;
  graph.filteredLinks = previousState.filteredLinks;

  layoutGraph();
  drawGraph();
  updateGraphUI();

  // Sync with column view if there's a selected node after going back
  if (graph.selectedNode) {
    console.log('Graph back navigation - syncing to column view');
    syncGraphToColumnView(graph.selectedNode);
  } else {
    console.log('Graph back navigation - no node selected');
  }

  // Automatically fit to view after going back
  setTimeout(() => {
    graphFitToView();
  }, 50);
}

function updateGraphUI() {
  // Update back button visibility and selection info
  const backBtn = byId('graphBackBtn');
  const selectionInfo = byId('graphSelectionInfo');
  const subtitle = byId('graphSubtitle');

  if (backBtn) {
    if (graph.history.length > 0 || graph.selectedNode) {
      backBtn.style.display = 'inline-block';
      backBtn.disabled = graph.history.length === 0 && !graph.selectedNode;
    } else {
      backBtn.style.display = 'none';
    }
  }

  if (selectionInfo) {
    if (graph.selectedNode) {
      const label = graph.selectedNode.fullLabel || graph.selectedNode.label;
      selectionInfo.innerHTML = `<span class="chip mono">${esc(graph.selectedNode.entityId)}</span> ${esc(label)}`;
      selectionInfo.style.display = 'block';
    } else {
      selectionInfo.style.display = 'none';
    }
  }

  // Update subtitle to show season filter
  if (subtitle) {
    const baseText = "Vertical flow: Groups ‚Üí Challenges ‚Üí Initiatives ‚Üí Systems ‚Üí KPIs";
    if (state.initSeason !== "ALL") {
      subtitle.textContent = `${baseText} ‚Ä¢ Filtered by ${state.initSeason}`;
    } else {
      subtitle.textContent = baseText;
    }
  }
}

function graphZoomIn() {
  graph.zoom *= 1.2;
  graph.zoom = Math.min(3, graph.zoom);
  drawGraph();
}

function graphZoomOut() {
  graph.zoom *= 0.8;
  graph.zoom = Math.max(0.3, graph.zoom);
  drawGraph();
}

function graphFontSizeIncrease() {
  graph.fontSize *= 1.2;
  graph.fontSize = Math.min(2.5, graph.fontSize);
  drawGraph();
}

function graphFontSizeDecrease() {
  graph.fontSize *= 0.8;
  graph.fontSize = Math.max(0.6, graph.fontSize);
  drawGraph();
}

function graphReset() {
  graph.zoom = 1;
  graph.panX = 0;
  graph.panY = 0;
  graph.fontSize = 1.0;
  graph.selectedNode = null;
  graph.filteredNodes = null;
  graph.filteredLinks = null;
  graph.history = [];
  layoutGraph();
  drawGraph();
  updateGraphUI();
}

function graphFitToView() {
  // Get visible nodes (filtered or all)
  const visibleNodes = graph.nodes.filter(node => {
    if (graph.filteredNodes) {
      return graph.filteredNodes.has(node.id);
    }
    return true;
  });

  if (visibleNodes.length === 0) return;

  // Calculate bounding box of visible nodes
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  visibleNodes.forEach(node => {
    const left = node.x - node.width / 2;
    const right = node.x + node.width / 2;
    const top = node.y - node.height / 2;
    const bottom = node.y + node.height / 2;

    minX = Math.min(minX, left);
    maxX = Math.max(maxX, right);
    minY = Math.min(minY, top);
    maxY = Math.max(maxY, bottom);
  });

  // Add padding
  const padding = 50;
  minX -= padding;
  maxX += padding;
  minY -= padding;
  maxY += padding;

  // Calculate content size
  const contentWidth = maxX - minX;
  const contentHeight = maxY - minY;

  // Get canvas size (in logical pixels, not device pixels)
  const canvas = graph.canvas;
  const rect = canvas.getBoundingClientRect();
  const canvasWidth = rect.width;
  const canvasHeight = rect.height;

  // Calculate zoom to fit
  const zoomX = canvasWidth / contentWidth;
  const zoomY = canvasHeight / contentHeight;
  const newZoom = Math.min(zoomX, zoomY, 3); // Cap at max zoom of 3

  // Calculate center of content
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  // Calculate pan to center the content
  graph.zoom = newZoom;
  graph.panX = canvasWidth / 2 - centerX * newZoom;
  graph.panY = canvasHeight / 2 - centerY * newZoom;

  drawGraph();
}

// Flag to prevent infinite sync loops
let isSyncing = false;

function syncGraphToColumnView(node) {
  if (isSyncing) return;
  isSyncing = true;

  try {
    // Map graph node type to column view type and extract entity ID
    let type = node.type;
    let id = node.entityId;

    console.log('syncGraphToColumnView - mapping type:', type, 'id:', id);

    // Update column view selection with appropriate tab
    if (type === 'group') {
      console.log('Calling select for challengeGroup:', id);
      select('challengeGroup', id, {forceSelect: true, autoTab: 'challenges'});
    } else if (type === 'challenge') {
      console.log('Calling select for subChallenge:', id);
      select('subChallenge', id, {forceSelect: true, autoTab: 'challenges'});
    } else if (type === 'initiative') {
      console.log('Calling select for initiative:', id);
      select('initiative', id, {forceSelect: true, autoTab: 'initiatives'});
    } else if (type === 'system') {
      console.log('Calling select for system:', id);
      select('system', id, {forceSelect: true, autoTab: 'systems'});
    } else if (type === 'kpi') {
      console.log('Calling select for kpi:', id);
      select('kpi', id, {forceSelect: true, autoTab: 'kpis'});
    } else {
      console.warn('Unknown node type in syncGraphToColumnView:', type);
    }
  } finally {
    isSyncing = false;
  }
}

function syncColumnToGraphView(type, id) {
  console.log('syncColumnToGraphView - isSyncing before:', isSyncing, 'canvas:', !!graph.canvas);

  if (isSyncing) {
    console.warn('Sync blocked by isSyncing flag - forcing reset');
    isSyncing = false; // Force reset if stuck
  }

  if (!graph.canvas) {
    console.log('syncColumnToGraphView skipped - no canvas');
    return;
  }

  isSyncing = true;
  console.log('syncColumnToGraphView - isSyncing set to TRUE');

  try {
    console.log('syncColumnToGraphView called with:', type, id);
    console.log('typeof type:', typeof type);
    console.log('type.length:', type.length);
    console.log('type === "initiative":', type === 'initiative');

    // Map column view type to graph node type
    let nodeType = type;
    console.log('After assignment, nodeType:', nodeType);
    if (type === 'challengeGroup') nodeType = 'group';
    console.log('After challengeGroup check, nodeType:', nodeType);
    if (type === 'subChallenge') nodeType = 'challenge';
    console.log('After subChallenge check, nodeType:', nodeType);

    console.log('Final mapped nodeType:', nodeType);

    // Rebuild graph data temporarily ignoring season filter to ensure node exists
    // (Column view selections should always be visible in graph)
    const savedSeason = state.initSeason;
    state.initSeason = "ALL";
    const { nodes, links } = buildGraphData();
    graph.nodes = nodes;
    graph.links = links;
    state.initSeason = savedSeason;

    // Now find the node
    const nodeId = `${nodeType}-${id}`;
    console.log('Looking for node with ID:', nodeId, 'in', graph.nodes.length, 'nodes');
    const node = graph.nodes.find(n => n.id === nodeId);
    console.log('Found node:', node ? node.id : 'NOT FOUND');

    if (node) {
      // Clear previous history to avoid confusion
      graph.history = [];

      // Select the node in the graph
      graph.selectedNode = node;

      // Build set of related nodes (same logic as selectGraphNode but without history)
      const relatedNodes = new Set();
      const relatedLinks = new Set();
      relatedNodes.add(node.id);

      // Find all nodes connected to this node
      graph.links.forEach(link => {
        if (link.source.id === node.id) {
          relatedNodes.add(link.target.id);
          relatedLinks.add(link);
        } else if (link.target.id === node.id) {
          relatedNodes.add(link.source.id);
          relatedLinks.add(link);
        }
      });

      // Apply full chain tracing logic based on node type
      if (node.type === 'group') {
        const subChallenges = new Set();
        graph.links.forEach(link => {
          if (link.source.id === node.id && link.type === 'group-challenge') {
            subChallenges.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        const initiativeNodes = new Set();
        graph.links.forEach(link => {
          if (subChallenges.has(link.source.id) && link.type === 'challenge-initiative') {
            initiativeNodes.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        const systemNodes = new Set();
        graph.links.forEach(link => {
          if (initiativeNodes.has(link.source.id) && link.type === 'initiative-system') {
            systemNodes.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (systemNodes.has(link.source.id) && link.type === 'system-kpi') {
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });
      } else if (node.type === 'challenge') {
        graph.links.forEach(link => {
          if (link.target.id === node.id && link.type === 'group-challenge') {
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        const initiativeNodes = new Set();
        graph.links.forEach(link => {
          if (link.source.id === node.id && link.type === 'challenge-initiative') {
            initiativeNodes.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        const systemNodes = new Set();
        graph.links.forEach(link => {
          if (initiativeNodes.has(link.source.id) && link.type === 'initiative-system') {
            systemNodes.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (systemNodes.has(link.source.id) && link.type === 'system-kpi') {
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });
      } else if (node.type === 'initiative') {
        const challengeNodes = new Set();
        graph.links.forEach(link => {
          if (link.target.id === node.id && link.type === 'challenge-initiative') {
            challengeNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (challengeNodes.has(link.target.id) && link.type === 'group-challenge') {
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        const systemNodes = new Set();
        graph.links.forEach(link => {
          if (link.source.id === node.id && link.type === 'initiative-system') {
            systemNodes.add(link.target.id);
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (systemNodes.has(link.source.id) && link.type === 'system-kpi') {
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });
      } else if (node.type === 'system') {
        const initiativeNodes = new Set();
        graph.links.forEach(link => {
          if (link.target.id === node.id && link.type === 'initiative-system') {
            initiativeNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        const challengeNodes = new Set();
        graph.links.forEach(link => {
          if (initiativeNodes.has(link.target.id) && link.type === 'challenge-initiative') {
            challengeNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (challengeNodes.has(link.target.id) && link.type === 'group-challenge') {
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (link.source.id === node.id && link.type === 'system-kpi') {
            relatedNodes.add(link.target.id);
            relatedLinks.add(link);
          }
        });
      } else if (node.type === 'kpi') {
        const systemNodes = new Set();
        graph.links.forEach(link => {
          if (link.target.id === node.id && link.type === 'system-kpi') {
            systemNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        const initiativeNodes = new Set();
        graph.links.forEach(link => {
          if (systemNodes.has(link.target.id) && link.type === 'initiative-system') {
            initiativeNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        const challengeNodes = new Set();
        graph.links.forEach(link => {
          if (initiativeNodes.has(link.target.id) && link.type === 'challenge-initiative') {
            challengeNodes.add(link.source.id);
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });

        graph.links.forEach(link => {
          if (challengeNodes.has(link.target.id) && link.type === 'group-challenge') {
            relatedNodes.add(link.source.id);
            relatedLinks.add(link);
          }
        });
      }

      // CLEANUP: Remove nodes that don't have any visible links
      // This prevents orphaned nodes from appearing without connections
      const nodesWithLinks = new Set();
      relatedLinks.forEach(link => {
        nodesWithLinks.add(link.source.id);
        nodesWithLinks.add(link.target.id);
      });

      // Only keep nodes that have at least one visible link
      const cleanedNodes = new Set();
      relatedNodes.forEach(nodeId => {
        if (nodesWithLinks.has(nodeId)) {
          cleanedNodes.add(nodeId);
        } else {
          console.log('CLEANUP: Removing orphaned node:', nodeId);
        }
      });

      console.log('Before cleanup: relatedNodes =', relatedNodes.size, ', relatedLinks =', relatedLinks.size);
      console.log('After cleanup: cleanedNodes =', cleanedNodes.size);
      console.log('Nodes in cleanedNodes:', Array.from(cleanedNodes));
      console.log('Links in relatedLinks:', relatedLinks.size, 'links');

      graph.filteredNodes = cleanedNodes;
      graph.filteredLinks = relatedLinks;

      layoutGraph();
      drawGraph();
      updateGraphUI();

      // Automatically fit to view after syncing
      setTimeout(() => {
        graphFitToView();
      }, 50);

      // Don't auto-sync to flow here - only sync when user switches to flow view
      // This prevents issues with flow not being initialized yet
    } else {
      console.log('Node not found in graph:', nodeType, id);
    }
  } finally {
    console.log('syncColumnToGraphView - resetting isSyncing to FALSE');
    isSyncing = false;
  }
}

/* ========================================
   SHARED FILTERING LOGIC
   ======================================== */

// Compute related entities based on type and ID
// Returns {relatedIds: Set, relatedLinks: Set} where links are identified by source-target pairs
function computeRelatedEntities(entityType, entityId, allLinks) {
  const relatedIds = new Set([entityId]);
  const relatedLinks = new Set();

  // Helper function to safely extract ID from link source/target
  // Handles both string IDs (Flow view) and object IDs (Graph view)
  function getLinkId(linkPart) {
    if (!linkPart) return null;
    if (typeof linkPart === 'string') return linkPart;
    if (linkPart.id) return linkPart.id;
    return null;
  }

  if (entityType === 'challengeGroup') {
    // Downstream: challengeGroup -> challenges -> initiatives -> systems -> kpis
    const challenges = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return; // Skip malformed links
      if (sourceId === entityId) {
        challenges.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });

    const initiatives = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (challenges.has(sourceId)) {
        initiatives.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });

    const systems = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (initiatives.has(sourceId)) {
        systems.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });

    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (systems.has(sourceId)) {
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
  } else if (entityType === 'challenge' || entityType === 'subChallenge') {
    // Upstream: challenge group
    // Downstream: challenge -> initiatives -> systems -> kpis

    console.log('computeRelatedEntities for challenge:', entityId);
    console.log('Total links to check:', allLinks.length);

    // Debug: Show sample links involving this challenge
    const sampleLinks = allLinks.filter(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      return sourceId === entityId || targetId === entityId;
    }).slice(0, 5);
    console.log('Sample links involving', entityId, ':', sampleLinks.map(l => ({
      source: getLinkId(l.source),
      target: getLinkId(l.target)
    })));

    // Find parent challenge group
    let foundParent = false;
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (targetId === entityId) {
        console.log('Found parent link! source:', sourceId, 'target:', targetId);
        relatedIds.add(sourceId); // Add the challenge group
        relatedLinks.add(link);
        foundParent = true;
      }
    });
    console.log('Found parent challenge group?', foundParent);

    // If no parent found, log links where target could match
    if (!foundParent) {
      console.log('Looking for links where target matches:', entityId);
      const possibleParents = allLinks.filter(link => {
        const targetId = getLinkId(link.target);
        return targetId && targetId.includes(entityId.split('.')[1]); // e.g., SC1
      }).slice(0, 3);
      console.log('Possible parent links:', possibleParents.map(l => ({
        source: getLinkId(l.source),
        target: getLinkId(l.target),
        link: l
      })));
    }

    const initiatives = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (sourceId === entityId) {
        console.log('Found initiative link! source:', sourceId, 'target:', targetId);
        initiatives.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
    console.log('Found', initiatives.size, 'initiatives:', Array.from(initiatives));

    const systems = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (initiatives.has(sourceId)) {
        systems.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
    console.log('Found', systems.size, 'systems:', Array.from(systems));

    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (systems.has(sourceId)) {
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
    console.log('Final relatedIds for challenge:', Array.from(relatedIds));
  } else if (entityType === 'initiative') {
    // Upstream: challenges + challenge groups; Downstream: systems, kpis
    const challenges = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (targetId === entityId || targetId.endsWith('-' + entityId)) {
        challenges.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    // Find parent challenge groups for these challenges
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (challenges.has(targetId)) {
        relatedIds.add(sourceId); // Add the challenge group
        relatedLinks.add(link);
      }
    });

    const systems = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (sourceId === entityId || sourceId.endsWith('-' + entityId)) {
        systems.add(targetId);
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });

    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (systems.has(sourceId)) {
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
  } else if (entityType === 'system') {
    // Upstream: initiatives, challenges, challenge groups; Downstream: kpis
    const initiatives = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (targetId === entityId || targetId.endsWith('-' + entityId)) {
        initiatives.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    const challenges = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (initiatives.has(targetId)) {
        challenges.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    // Find parent challenge groups
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (challenges.has(targetId)) {
        relatedIds.add(sourceId); // Add the challenge group
        relatedLinks.add(link);
      }
    });

    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (sourceId === entityId || sourceId.endsWith('-' + entityId)) {
        relatedIds.add(targetId);
        relatedLinks.add(link);
      }
    });
  } else if (entityType === 'kpi') {
    // Upstream: systems, initiatives, challenges
    const systems = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (targetId === entityId || targetId.endsWith('-' + entityId)) {
        systems.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    const initiatives = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (systems.has(targetId)) {
        initiatives.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    const challenges = new Set();
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (initiatives.has(targetId)) {
        challenges.add(sourceId);
        relatedIds.add(sourceId);
        relatedLinks.add(link);
      }
    });

    // Find parent challenge groups
    allLinks.forEach(link => {
      const sourceId = getLinkId(link.source);
      const targetId = getLinkId(link.target);
      if (!sourceId || !targetId) return;
      if (challenges.has(targetId)) {
        relatedIds.add(sourceId); // Add the challenge group
        relatedLinks.add(link);
      }
    });
  }

  return { relatedIds, relatedLinks };
}

/* ========================================
   FLOW VIEW (SANKEY DIAGRAM)
   ======================================== */

const flow = {
  canvas: null,
  ctx: null,
  zoom: 1,
  panX: 0,
  panY: 0,
  nodes: [],
  links: [],
  hovering: null,
  selectedNode: null,
  filteredNodes: null,
  filteredLinks: null,
  colors: {},    // Cache for colors
  fontSize: 1.0  // Font size multiplier (0.8, 1.0, 1.2, 1.5, 2.0)
};

function initFlowView() {
  const canvas = document.getElementById('flowCanvas');
  if (!canvas) return;

  flow.canvas = canvas;
  flow.ctx = canvas.getContext('2d');

  // Set actual canvas size to match display size
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * window.devicePixelRatio;
  canvas.height = rect.height * window.devicePixelRatio;
  flow.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

  // Cache colors once at initialization
  flow.colors = {
    group: getComputedStyle(document.documentElement).getPropertyValue('--graph-group').trim(),
    challenge: getComputedStyle(document.documentElement).getPropertyValue('--c-challenge').trim(),
    initiative: getComputedStyle(document.documentElement).getPropertyValue('--c-initiative').trim(),
    system: getComputedStyle(document.documentElement).getPropertyValue('--c-system').trim(),
    kpi: getComputedStyle(document.documentElement).getPropertyValue('--c-kpi').trim()
  };

  console.log('Flow colors initialized:', flow.colors);

  buildFlowData();
  layoutFlowDiagram();
  drawFlowDiagram();
  setupFlowInteractions();
  updateFlowUI();
}

function buildFlowData() {
  flow.nodes = [];
  flow.links = [];

  // Filter initiatives by season first
  let filteredInitiatives = DATA.initiatives;
  if (state.initSeason !== "ALL") {
    filteredInitiatives = DATA.initiatives.filter(i => i.season === state.initSeason);
    console.log('Flow view filtered to season', state.initSeason, ':', filteredInitiatives.length, 'initiatives');
  }

  // Build nodes for each column
  // Column 0: Challenge Groups (C1, C2, C3...)
  const challengeGroups = DATA.challengeGroups.map(cg => ({
    id: cg.id,
    label: cg.title,
    type: 'challengeGroup',
    column: 0,
    value: 0
  }));

  // Column 1: Sub-Challenges
  const challenges = DATA.subChallenges.map(sc => ({
    id: sc.id,
    label: sc.text,
    type: 'challenge',
    column: 1,
    value: 0 // Will be calculated from links
  }));

  // Column 2: Initiatives (filtered by season)
  const initiatives = filteredInitiatives.map(init => ({
    id: init.id,
    label: init.text,
    type: 'initiative',
    column: 2,
    value: 0
  }));

  // Column 3: Systems
  const systems = DATA.systems.map(sys => ({
    id: sys.id,
    label: sys.title || sys.text,
    type: 'system',
    column: 3,
    value: 0
  }));

  // Column 4: KPIs
  const kpis = DATA.kpis.map(kpi => ({
    id: kpi.id,
    label: kpi.text,
    type: 'kpi',
    column: 4,
    value: 0
  }));

  flow.nodes = [...challengeGroups, ...challenges, ...initiatives, ...systems, ...kpis];

  // Build links: Challenge Group -> Sub-Challenge
  DATA.subChallenges.forEach(sc => {
    const link = {
      source: sc.groupId,  // Fixed: Use camelCase field name from Python conversion
      target: sc.id,
      value: 3 // Lower weight for group‚Üíchallenge links
    };
    flow.links.push(link);

    // Debug: Log first few group->challenge links
    if (flow.links.length <= 3) {
      console.log('Created group->challenge link:', link.source, '->', link.target);
    }
  });

  // Build links: Challenge -> Initiative (only for filtered initiatives)
  filteredInitiatives.forEach(init => {
    if (init.challenges && init.challenges.length > 0) {
      init.challenges.forEach(link => {
        flow.links.push({
          source: link.challengeId,
          target: init.id,
          value: link.weight || 5,
          impact: link.impact || 'M'
        });
      });
    }
  });

  // Build links: Initiative -> System
  DATA.systems.forEach(sys => {
    if (sys.initiatives && sys.initiatives.length > 0) {
      sys.initiatives.forEach(link => {
        flow.links.push({
          source: link.initiativeId,
          target: sys.id,
          value: link.weight || 5
        });
      });
    }
  });

  // Build links: System -> KPI
  DATA.kpis.forEach(kpi => {
    if (kpi.systems && kpi.systems.length > 0) {
      kpi.systems.forEach(link => {
        flow.links.push({
          source: link.systemId,
          target: kpi.id,
          value: link.weight || 5
        });
      });
    }
  });

  // If season filter is active, only include nodes that are connected
  if (state.initSeason !== "ALL") {
    const connectedNodeIds = new Set();

    // Add all filtered initiative nodes
    filteredInitiatives.forEach(init => {
      connectedNodeIds.add(init.id);
    });

    // Add connected challenges (upstream from initiatives)
    flow.links.forEach(link => {
      if (connectedNodeIds.has(link.target)) {
        connectedNodeIds.add(link.source);
      }
    });

    // Add connected systems (downstream from initiatives)
    flow.links.forEach(link => {
      if (connectedNodeIds.has(link.source)) {
        connectedNodeIds.add(link.target);
      }
    });

    // Add connected KPIs (downstream from systems)
    const systemIds = new Set();
    flow.links.forEach(link => {
      if (link.source.startsWith && !link.source.startsWith('C') && connectedNodeIds.has(link.source)) {
        systemIds.add(link.source);
      }
    });
    flow.links.forEach(link => {
      if (systemIds.has(link.source)) {
        connectedNodeIds.add(link.target);
      }
    });

    // Filter nodes to only include connected ones
    flow.nodes = flow.nodes.filter(node => connectedNodeIds.has(node.id));

    // Filter links to only include those between connected nodes
    flow.links = flow.links.filter(link =>
      connectedNodeIds.has(link.source) && connectedNodeIds.has(link.target)
    );

    console.log('Flow view after season filter:', flow.nodes.length, 'nodes,', flow.links.length, 'links');
  }

  // Calculate node values (sum of incoming/outgoing links)
  flow.nodes.forEach(node => {
    const incoming = flow.links.filter(l => l.target === node.id).reduce((sum, l) => sum + l.value, 0);
    const outgoing = flow.links.filter(l => l.source === node.id).reduce((sum, l) => sum + l.value, 0);
    node.value = Math.max(incoming, outgoing, 1); // At least 1
  });
}

function layoutFlowDiagram() {
  const canvas = flow.canvas;
  const padding = 80;
  const columnWidth = (canvas.width - padding * 2) / 5;
  const columnSpacing = columnWidth;

  // Determine which nodes to layout (filtered or all)
  const nodesToLayout = flow.filteredNodes
    ? flow.nodes.filter(n => flow.filteredNodes.has(n.id))
    : flow.nodes;

  // Group nodes by column (now 5 columns)
  const columns = [[], [], [], [], []];
  nodesToLayout.forEach(node => {
    columns[node.column].push(node);
  });

  // Layout each column - only layout columns that have visible nodes
  columns.forEach((colNodes, colIndex) => {
    if (colNodes.length === 0) return; // Skip empty columns

    const totalValue = colNodes.reduce((sum, n) => sum + n.value, 0);
    const availableHeight = canvas.height - padding * 2;
    const spacing = 20;
    const totalSpacing = spacing * (colNodes.length - 1);

    // Calculate scale, but set reasonable min/max height for nodes
    const minNodeHeight = 30;  // Minimum height per node
    const maxNodeHeight = 150; // Maximum height per node
    let scale = (availableHeight - totalSpacing) / Math.max(totalValue, 1);

    // Check if this would make nodes too big or too small
    const avgNodeHeight = (colNodes.reduce((sum, n) => sum + n.value * scale, 0)) / colNodes.length;
    if (avgNodeHeight > maxNodeHeight) {
      // Nodes would be too big, use max height instead
      scale = maxNodeHeight / (totalValue / colNodes.length);
    } else if (avgNodeHeight < minNodeHeight) {
      // Nodes would be too small, use min height instead
      scale = minNodeHeight / (totalValue / colNodes.length);
    }

    let y = padding;
    colNodes.forEach(node => {
      node.x = padding + colIndex * columnSpacing + columnWidth / 2;
      node.y = y;
      node.height = Math.max(minNodeHeight, Math.min(maxNodeHeight, node.value * scale));
      node.width = 40;
      y += node.height + spacing;
    });
  });
}

function drawFlowDiagram() {
  const ctx = flow.ctx;
  const canvas = flow.canvas;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();

  // Apply zoom and pan
  ctx.translate(flow.panX, flow.panY);
  ctx.scale(flow.zoom, flow.zoom);

  // Draw links first (behind nodes)
  flow.links.forEach(link => {
    const sourceNode = flow.nodes.find(n => n.id === link.source);
    const targetNode = flow.nodes.find(n => n.id === link.target);

    if (!sourceNode || !targetNode) return;

    // Skip if filtered out
    if (flow.filteredLinks && !flow.filteredLinks.has(link)) return;

    const isHovered = flow.hovering && (flow.hovering.source === link.source && flow.hovering.target === link.target);

    // Calculate link thickness based on value
    const maxWeight = 10;
    const minThickness = 2;
    const maxThickness = 30;
    const thickness = minThickness + (link.value / maxWeight) * (maxThickness - minThickness);

    // Get colors for source and target nodes (use cached colors)
    let sourceColor, targetColor;

    if (sourceNode.type === 'challengeGroup') sourceColor = flow.colors.group;
    else if (sourceNode.type === 'challenge') sourceColor = flow.colors.challenge;
    else if (sourceNode.type === 'initiative') sourceColor = flow.colors.initiative;
    else if (sourceNode.type === 'system') sourceColor = flow.colors.system;
    else sourceColor = flow.colors.kpi;

    if (targetNode.type === 'challengeGroup') targetColor = flow.colors.group;
    else if (targetNode.type === 'challenge') targetColor = flow.colors.challenge;
    else if (targetNode.type === 'initiative') targetColor = flow.colors.initiative;
    else if (targetNode.type === 'system') targetColor = flow.colors.system;
    else targetColor = flow.colors.kpi;

    // Create gradient from source to target
    const startX = sourceNode.x + sourceNode.width / 2;
    const startY = sourceNode.y + sourceNode.height / 2;
    const endX = targetNode.x - targetNode.width / 2;
    const endY = targetNode.y + targetNode.height / 2;

    const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
    gradient.addColorStop(0, isHovered ? sourceColor : sourceColor + '80');
    gradient.addColorStop(1, isHovered ? targetColor : targetColor + '80');

    // Draw bezier curve
    ctx.beginPath();
    ctx.moveTo(startX, startY);

    const controlX1 = sourceNode.x + (targetNode.x - sourceNode.x) * 0.5;
    const controlY1 = sourceNode.y + sourceNode.height / 2;
    const controlX2 = sourceNode.x + (targetNode.x - sourceNode.x) * 0.5;
    const controlY2 = targetNode.y + targetNode.height / 2;

    ctx.bezierCurveTo(
      controlX1, controlY1,
      controlX2, controlY2,
      endX, endY
    );

    ctx.lineWidth = thickness;
    ctx.strokeStyle = gradient;
    ctx.stroke();
  });

  // Draw nodes
  flow.nodes.forEach(node => {
    // Skip if filtered out
    if (flow.filteredNodes && !flow.filteredNodes.has(node.id)) return;

    const isHovered = flow.hovering && flow.hovering.id === node.id;
    const isSelected = flow.selectedNode && flow.selectedNode.id === node.id;

    // Use cached colors
    let color;
    if (node.type === 'challengeGroup') color = flow.colors.group;
    else if (node.type === 'challenge') color = flow.colors.challenge;
    else if (node.type === 'initiative') color = flow.colors.initiative;
    else if (node.type === 'system') color = flow.colors.system;
    else color = flow.colors.kpi;

    // Draw small colored circle/dot instead of big box
    const dotRadius = isSelected ? 8 : (isHovered ? 6 : 5);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(node.x, node.y + node.height / 2, dotRadius, 0, Math.PI * 2);
    ctx.fill();

    // Draw white border on hover or selection
    if (isSelected) {
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.stroke();

      // Draw outer glow ring for selected node
      ctx.beginPath();
      ctx.arc(node.x, node.y + node.height / 2, dotRadius + 4, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 2;
      ctx.stroke();
    } else if (isHovered) {
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    // Draw label with background when hovered or selected
    const baseFontSize = (isSelected || isHovered) ? 11 : 10;
    const fontSize = Math.round(baseFontSize * flow.fontSize);
    const fontWeight = (isSelected || isHovered) ? 'bold' : 'normal';
    ctx.font = `${fontWeight} ${fontSize}px sans-serif`;
    ctx.textAlign = node.column < 3 ? 'right' : 'left';
    const textX = node.column < 3 ? node.x - 15 : node.x + 15;
    const textY = node.y + node.height / 2 + 4;

    // For challenge GROUPS, show just the ID (C1, C2, C3...)
    // For everything else, show the full label
    let displayLabel;
    if (node.type === 'challengeGroup') {
      // Show just the ID for challenge groups (e.g., "C1", "C2")
      displayLabel = node.id;
    } else {
      // For sub-challenges, initiatives, systems, KPIs: show full text (truncated if needed)
      displayLabel = node.label.length > 30 ? node.label.substring(0, 30) + '...' : node.label;
    }

    // Draw background highlight when hovering or selected to make it clear
    if (isSelected || isHovered) {
      const textMetrics = ctx.measureText(displayLabel);
      const padding = 4;
      let bgX, bgWidth;

      if (node.column < 3) {
        // Text on left
        bgX = textX - textMetrics.width - padding;
        bgWidth = textMetrics.width + padding * 2;
      } else {
        // Text on right
        bgX = textX - padding;
        bgWidth = textMetrics.width + padding * 2;
      }

      ctx.fillStyle = isSelected ? 'rgba(255, 255, 255, 0.3)' : 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(bgX, textY - 10, bgWidth, 16);
    }

    ctx.fillStyle = (isSelected || isHovered) ? '#ffffff' : '#e8eefc';
    ctx.fillText(displayLabel, textX, textY);
  });

  ctx.restore();
}

function findFlowNodeAt(x, y) {
  // Check if clicking on a visible node
  const nodesToCheck = flow.filteredNodes
    ? flow.nodes.filter(n => flow.filteredNodes.has(n.id))
    : flow.nodes;

  return nodesToCheck.find(node => {
    // Expand hitbox to include dot and text label area
    const dotRadius = 10;
    const textPadding = 150;
    let hitboxLeft, hitboxRight;

    if (node.column < 3) {
      // Text on left side, dot on right
      hitboxLeft = node.x - textPadding;
      hitboxRight = node.x + dotRadius;
    } else {
      // Text on right side, dot on left
      hitboxLeft = node.x - dotRadius;
      hitboxRight = node.x + textPadding;
    }

    const nodeCenter = node.y + node.height / 2;
    const verticalPadding = 15;

    return x >= hitboxLeft &&
           x <= hitboxRight &&
           y >= nodeCenter - verticalPadding &&
           y <= nodeCenter + verticalPadding;
  });
}

function setupFlowInteractions() {
  const canvas = flow.canvas;
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let clickStart = { x: 0, y: 0, time: 0 };

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - flow.panX) / flow.zoom;
    const y = (e.clientY - rect.top - flow.panY) / flow.zoom;

    clickStart = { x: e.clientX, y: e.clientY, time: Date.now() };

    // Check if clicking on a node
    const node = findFlowNodeAt(x, y);
    if (!node) {
      isDragging = true;
      dragStart = { x: e.clientX - flow.panX, y: e.clientY - flow.panY };
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - flow.panX) / flow.zoom;
    const y = (e.clientY - rect.top - flow.panY) / flow.zoom;

    if (isDragging) {
      flow.panX = e.clientX - dragStart.x;
      flow.panY = e.clientY - dragStart.y;
      updateFlowTooltip(null); // Hide tooltip when panning
      drawFlowDiagram();
    } else {
      // Hover detection
      const node = findFlowNodeAt(x, y);
      if (node !== flow.hovering) {
        flow.hovering = node;
        canvas.style.cursor = node ? 'pointer' : 'grab';
        drawFlowDiagram();
      }
      // Update tooltip
      if (node) {
        updateFlowTooltip(node, e.clientX, e.clientY);
      } else {
        updateFlowTooltip(null);
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    const timeDiff = Date.now() - clickStart.time;
    const distMoved = Math.sqrt(
      Math.pow(e.clientX - clickStart.x, 2) + Math.pow(e.clientY - clickStart.y, 2)
    );

    // If it's a quick click without much movement, treat as node selection
    if (timeDiff < 300 && distMoved < 5) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left - flow.panX) / flow.zoom;
      const y = (e.clientY - rect.top - flow.panY) / flow.zoom;
      const node = findFlowNodeAt(x, y);

      if (node) {
        console.log('Selecting flow node:', node.id);
        selectFlowNode(node.id);
      }
    }

    isDragging = false;
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
    flow.hovering = null;
    canvas.style.cursor = 'grab';
    updateFlowTooltip(null);
    drawFlowDiagram();
  });

  // Touch support for mobile devices
  let touches = [];
  let lastTouchDistance = 0;
  let touchStart = { x: 0, y: 0, time: 0 };

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    touches = Array.from(e.touches);

    if (touches.length === 1) {
      const touch = touches[0];
      const rect = canvas.getBoundingClientRect();
      touchStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now()
      };

      const x = (touch.clientX - rect.left - flow.panX) / flow.zoom;
      const y = (touch.clientY - rect.top - flow.panY) / flow.zoom;

      const node = findFlowNodeAt(x, y);
      if (!node) {
        isDragging = true;
        dragStart = { x: touch.clientX - flow.panX, y: touch.clientY - flow.panY };
      }
    } else if (touches.length === 2) {
      isDragging = false;
      lastTouchDistance = getTouchDistance(touches[0], touches[1]);
    }
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    touches = Array.from(e.touches);

    if (touches.length === 1 && isDragging) {
      const touch = touches[0];
      flow.panX = touch.clientX - dragStart.x;
      flow.panY = touch.clientY - dragStart.y;
      drawFlowDiagram();
    } else if (touches.length === 2) {
      const currentDistance = getTouchDistance(touches[0], touches[1]);

      if (lastTouchDistance > 0) {
        const scaleFactor = currentDistance / lastTouchDistance;
        const oldZoom = flow.zoom;
        flow.zoom *= scaleFactor;
        flow.zoom = Math.max(0.3, Math.min(3, flow.zoom));

        const rect = canvas.getBoundingClientRect();
        const centerX = (touches[0].clientX + touches[1].clientX) / 2 - rect.left;
        const centerY = (touches[0].clientY + touches[1].clientY) / 2 - rect.top;

        const zoomChange = flow.zoom / oldZoom;
        flow.panX = centerX - (centerX - flow.panX) * zoomChange;
        flow.panY = centerY - (centerY - flow.panY) * zoomChange;

        drawFlowDiagram();
      }

      lastTouchDistance = currentDistance;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();

    const timeDiff = Date.now() - touchStart.time;

    if (touches.length === 1 && timeDiff < 300) {
      const touch = touches[0];
      const distMoved = Math.sqrt(
        Math.pow(touch.clientX - touchStart.x, 2) +
        Math.pow(touch.clientY - touchStart.y, 2)
      );

      if (distMoved < 10) {
        const rect = canvas.getBoundingClientRect();
        const x = (touch.clientX - rect.left - flow.panX) / flow.zoom;
        const y = (touch.clientY - rect.top - flow.panY) / flow.zoom;
        const node = findFlowNodeAt(x, y);

        if (node) {
          selectFlowNode(node.id);
        }
      }
    }

    touches = Array.from(e.touches);
    if (touches.length === 0) {
      isDragging = false;
      lastTouchDistance = 0;
    } else if (touches.length === 1) {
      lastTouchDistance = 0;
      const touch = touches[0];
      dragStart = { x: touch.clientX - flow.panX, y: touch.clientY - flow.panY };
    }
  }, { passive: false });

  function getTouchDistance(touch1, touch2) {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  // Mouse wheel zoom for desktop
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    const oldZoom = flow.zoom;
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    flow.zoom *= delta;
    flow.zoom = Math.max(0.3, Math.min(3, flow.zoom));

    const zoomChange = flow.zoom / oldZoom;
    flow.panX = mouseX - (mouseX - flow.panX) * zoomChange;
    flow.panY = mouseY - (mouseY - flow.panY) * zoomChange;

    drawFlowDiagram();
  }, { passive: false });
}

function updateFlowTooltip(node, mouseX, mouseY) {
  const tooltip = document.getElementById('flowTooltip');

  if (!node) {
    tooltip.style.display = 'none';
    return;
  }

  tooltip.textContent = node.label;
  tooltip.style.display = 'block';

  const canvas = document.getElementById('flowCanvas');
  const canvasRect = canvas.getBoundingClientRect();
  const offsetX = 15;
  const offsetY = 15;

  let tooltipX = mouseX - canvasRect.left + offsetX;
  let tooltipY = mouseY - canvasRect.top + offsetY;

  const tooltipRect = tooltip.getBoundingClientRect();
  if (tooltipX + tooltipRect.width > canvasRect.width) {
    tooltipX = mouseX - canvasRect.left - tooltipRect.width - offsetX;
  }
  if (tooltipY + tooltipRect.height > canvasRect.height) {
    tooltipY = mouseY - canvasRect.top - tooltipRect.height - offsetY;
  }

  tooltip.style.left = tooltipX + 'px';
  tooltip.style.top = tooltipY + 'px';
}

function flowZoomIn() {
  flow.zoom = Math.min(flow.zoom * 1.2, 3);
  drawFlowDiagram();
}

function flowZoomOut() {
  flow.zoom = Math.max(flow.zoom / 1.2, 0.3);
  drawFlowDiagram();
}

function flowFontSizeIncrease() {
  flow.fontSize *= 1.2;
  flow.fontSize = Math.min(2.5, flow.fontSize);
  drawFlowDiagram();
}

function flowFontSizeDecrease() {
  flow.fontSize *= 0.8;
  flow.fontSize = Math.max(0.6, flow.fontSize);
  drawFlowDiagram();
}

function flowReset() {
  flow.zoom = 1;
  flow.panX = 0;
  flow.panY = 0;
  flow.fontSize = 1.0;
  flow.selectedNode = null;
  flow.filteredNodes = null;
  flow.filteredLinks = null;
  layoutFlowDiagram();
  drawFlowDiagram();
  updateFlowUI();
}

function flowFitToView() {
  // Get visible nodes (filtered or all)
  const visibleNodes = flow.nodes.filter(node => {
    if (flow.filteredNodes) {
      return flow.filteredNodes.has(node.id);
    }
    return true;
  });

  if (visibleNodes.length === 0) return;

  // Calculate bounding box of visible nodes
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  visibleNodes.forEach(node => {
    const left = node.x;
    const right = node.x;
    const top = node.y;
    const bottom = node.y + node.height;

    minX = Math.min(minX, left);
    maxX = Math.max(maxX, right);
    minY = Math.min(minY, top);
    maxY = Math.max(maxY, bottom);
  });

  // Add padding
  const padding = 100;
  minX -= padding;
  maxX += padding;
  minY -= padding;
  maxY += padding;

  // Calculate content size
  const contentWidth = maxX - minX;
  const contentHeight = maxY - minY;

  // Get canvas size (in logical pixels, not device pixels)
  const canvas = flow.canvas;
  const rect = canvas.getBoundingClientRect();
  const canvasWidth = rect.width;
  const canvasHeight = rect.height;

  // Calculate zoom to fit
  const zoomX = canvasWidth / contentWidth;
  const zoomY = canvasHeight / contentHeight;
  const newZoom = Math.min(zoomX, zoomY, 3); // Cap at max zoom of 3

  // Calculate center of content
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;

  // Calculate pan to center the content
  flow.zoom = newZoom;
  flow.panX = canvasWidth / 2 - centerX * newZoom;
  flow.panY = canvasHeight / 2 - centerY * newZoom;

  drawFlowDiagram();
}

function updateFlowUI() {
  // Update selection info display
  const selectionInfo = byId('flowSelectionInfo');
  const subtitle = byId('flowSubtitle');

  if (selectionInfo) {
    if (flow.selectedNode) {
      const label = flow.selectedNode.label;
      const nodeTypeLabel = {
        'challengeGroup': 'Group',
        'challenge': 'Challenge',
        'initiative': 'Initiative',
        'system': 'System',
        'kpi': 'KPI'
      }[flow.selectedNode.type] || flow.selectedNode.type;

      selectionInfo.innerHTML = `<strong>Selected ${nodeTypeLabel}:</strong> <span class="chip mono">${esc(flow.selectedNode.id)}</span> ${esc(label)}`;
      selectionInfo.style.display = 'block';
    } else {
      selectionInfo.style.display = 'none';
    }
  }

  // Update subtitle to show season filter
  if (subtitle) {
    const baseText = "Visualize relationship strength through flow thickness";
    if (state.initSeason !== "ALL") {
      subtitle.textContent = `${baseText} ‚Ä¢ Filtered by ${state.initSeason}`;
    } else {
      subtitle.textContent = baseText;
    }
  }
}

function selectFlowNode(nodeId) {
  console.log('selectFlowNode called with nodeId:', nodeId);
  const node = flow.nodes.find(n => n.id === nodeId);
  if (!node) {
    console.log('Node not found in flow:', nodeId);
    console.log('Available flow node IDs:', flow.nodes.map(n => n.id).slice(0, 10));
    flow.selectedNode = null;
    flow.filteredNodes = null;
    flow.filteredLinks = null;
    layoutFlowDiagram(); // Re-layout to use full space
    drawFlowDiagram();
    updateFlowUI();
    return;
  }

  console.log('Found flow node:', node.id, 'type:', node.type);
  flow.selectedNode = node;

  // Use shared filtering logic
  console.log('Calling computeRelatedEntities with type:', node.type, 'id:', node.id);
  const { relatedIds, relatedLinks } = computeRelatedEntities(node.type, node.id, flow.links);

  console.log('computeRelatedEntities returned', relatedIds.size, 'related IDs:', Array.from(relatedIds));
  console.log('computeRelatedEntities returned', relatedLinks.size, 'related links');

  flow.filteredNodes = relatedIds;
  flow.filteredLinks = relatedLinks;

  // Re-layout the filtered nodes to use all available space
  layoutFlowDiagram();
  drawFlowDiagram();
  updateFlowUI();

  // Sync to Graph view if it's initialized AND not already syncing
  if (graph.canvas && !isSyncing) {
    console.log('Syncing flow selection to graph view');
    syncFlowToGraphView();
  }

  // Also sync to Column view to update the selection state in the sidebar
  if (!isSyncing && flow.selectedNode) {
    console.log('selectFlowNode - syncing back to column view');
    const columnType = flow.selectedNode.type === 'challengeGroup' ? 'challengeGroup' :
                       flow.selectedNode.type === 'challenge' ? 'subChallenge' :
                       flow.selectedNode.type;
    const autoTab = flow.selectedNode.type === 'challengeGroup' || flow.selectedNode.type === 'challenge' ? 'challenges' :
                    flow.selectedNode.type === 'initiative' ? 'initiatives' :
                    flow.selectedNode.type === 'system' ? 'systems' : 'kpis';

    isSyncing = true;
    try {
      select(columnType, flow.selectedNode.id, {forceSelect: true, autoTab: autoTab});
    } finally {
      isSyncing = false;
    }
  }
}

function syncColumnToFlowView(type, id) {
  if (!flow.canvas) {
    console.log('syncColumnToFlowView skipped - no canvas');
    return;
  }

  console.log('syncColumnToFlowView called with type:', type, 'id:', id);

  // The ID from column view matches directly with flow node IDs
  selectFlowNode(id);
}

function syncGraphToFlowView() {
  if (!graph.selectedNode) {
    console.log('syncGraphToFlowView - no graph selection');
    return;
  }

  if (!flow.canvas) {
    console.log('syncGraphToFlowView - flow not initialized, skipping');
    return;
  }

  // Map graph node to flow node ID
  const entityId = graph.selectedNode.entityId;
  console.log('syncGraphToFlowView - syncing graph selection to flow:', entityId);
  selectFlowNode(entityId);
}

function syncFlowToGraphView() {
  if (!flow.selectedNode) {
    console.log('syncFlowToGraphView - no flow selection');
    return;
  }

  if (!graph.canvas) {
    console.log('syncFlowToGraphView - graph not initialized, skipping');
    return;
  }

  // Map flow node to graph node
  const entityId = flow.selectedNode.id;
  const entityType = flow.selectedNode.type;

  console.log('syncFlowToGraphView - syncing flow selection to graph:', entityType, entityId);

  // Find the corresponding graph node
  let graphNodeId;
  if (entityType === 'challengeGroup') {
    graphNodeId = `group-${entityId}`;
  } else if (entityType === 'challenge') {
    graphNodeId = `challenge-${entityId}`;
  } else if (entityType === 'initiative') {
    graphNodeId = `initiative-${entityId}`;
  } else if (entityType === 'system') {
    graphNodeId = `system-${entityId}`;
  } else if (entityType === 'kpi') {
    graphNodeId = `kpi-${entityId}`;
  }

  const graphNode = graph.nodes.find(n => n.id === graphNodeId);
  if (graphNode) {
    console.log('Found corresponding graph node:', graphNodeId);
    selectGraphNode(graphNode);
  } else {
    console.log('Graph node not found for:', graphNodeId);
  }
}

/* ========================================
   BOOTSTRAP
   ======================================== */
function bootstrap() {
  renderTabs();
  wireSearch();
  renderChallengeTree();
  renderInitiativeList();
  renderSystemList();
  renderKpiList();
  renderWorkbench();
  setInitSeason(state.initSeason);

  initFromHash();
  renderFocusedDetail();
}

bootstrap();
</script>
</body>
</html>